<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>
	Comments on: is software engineering?	</title>
	<atom:link href="https://www.ultrasaurus.com/2006/03/is-software-engineering/feed/" rel="self" type="application/rss+xml" />
	<link>https://www.ultrasaurus.com/2006/03/is-software-engineering/</link>
	<description>Sarah Allen&#039;s reflections on internet software and other topics</description>
	<lastBuildDate>Sun, 12 Mar 2006 15:31:53 +0000</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.7.1</generator>
	<item>
		<title>
		By: Sarah Allen		</title>
		<link>https://www.ultrasaurus.com/2006/03/is-software-engineering/#comment-269</link>

		<dc:creator><![CDATA[Sarah Allen]]></dc:creator>
		<pubDate>Sun, 12 Mar 2006 15:31:53 +0000</pubDate>
		<guid isPermaLink="false">https://www.ultrasaurus.com/wordpress/?p=217#comment-269</guid>

					<description><![CDATA[I&#039;m not completely convinced by the code-as-design theory either; however, I think the authors point is exactly that &quot;compiling code is not like &#039;building&#039; hardware.&quot;  With production codes so low, it changes how we think about building stuff.  You can build a tree house without spending a lot of time designing too -- and it may fall apart next year -- just like some software built with little thought to design.

I do like his thoughts on how a lot of testing-and-debugging is done at the coding stage and how it is similar to testing done on the design of a bridge or a skyscraper.

Sarah
]]></description>
			<content:encoded><![CDATA[<p>I&#8217;m not completely convinced by the code-as-design theory either; however, I think the authors point is exactly that &#8220;compiling code is not like &#8216;building&#8217; hardware.&#8221;  With production codes so low, it changes how we think about building stuff.  You can build a tree house without spending a lot of time designing too &#8212; and it may fall apart next year &#8212; just like some software built with little thought to design.</p>
<p>I do like his thoughts on how a lot of testing-and-debugging is done at the coding stage and how it is similar to testing done on the design of a bridge or a skyscraper.</p>
<p>Sarah</p>
]]></content:encoded>
		
			</item>
		<item>
		<title>
		By: Rafhael Cedeno		</title>
		<link>https://www.ultrasaurus.com/2006/03/is-software-engineering/#comment-268</link>

		<dc:creator><![CDATA[Rafhael Cedeno]]></dc:creator>
		<pubDate>Thu, 09 Mar 2006 07:30:09 +0000</pubDate>
		<guid isPermaLink="false">https://www.ultrasaurus.com/wordpress/?p=217#comment-268</guid>

					<description><![CDATA[I don&#039;t quite understand how you can say software design is the source code.  You can often write code without spending a whole lot of time designing, but you can also build a table without spending a lot of time designing.  Building a skyscraper, however, requires tremendous amounts of design, same as building an operating system, or new crytographic routine, etc.  Many RFCs are just that, designs that often have no implementations.

Compiling code is not like &#039;building&#039; hardware.  Building something, as in &#039;give form to, from a plan&#039;, is actually the coding process.  Your plan is the design and it could be described mathematically, or through diagrams, or just in plain English.  Someone has to build that now, make it the program.

How would you apply the compile/link analogy to byte-compiled language? or perhaps to an interpreted language.  In that case, you dont even have a compiler/linker, its just reading lisp code and interpreting it.  Does that mean you cannot build Lisp code?

Still interesting, thanks for a distraction :)

Say hi to Pablo for me.

]]></description>
			<content:encoded><![CDATA[<p>I don&#8217;t quite understand how you can say software design is the source code.  You can often write code without spending a whole lot of time designing, but you can also build a table without spending a lot of time designing.  Building a skyscraper, however, requires tremendous amounts of design, same as building an operating system, or new crytographic routine, etc.  Many RFCs are just that, designs that often have no implementations.</p>
<p>Compiling code is not like &#8216;building&#8217; hardware.  Building something, as in &#8216;give form to, from a plan&#8217;, is actually the coding process.  Your plan is the design and it could be described mathematically, or through diagrams, or just in plain English.  Someone has to build that now, make it the program.</p>
<p>How would you apply the compile/link analogy to byte-compiled language? or perhaps to an interpreted language.  In that case, you dont even have a compiler/linker, its just reading lisp code and interpreting it.  Does that mean you cannot build Lisp code?</p>
<p>Still interesting, thanks for a distraction :)</p>
<p>Say hi to Pablo for me.</p>
]]></content:encoded>
		
			</item>
	</channel>
</rss>
