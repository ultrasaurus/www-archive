<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>
	Comments on: planning xp	</title>
	<atom:link href="/2009/07/planning-xp/feed/" rel="self" type="application/rss+xml" />
	<link>/2009/07/planning-xp/</link>
	<description>Sarah Allen&#039;s reflections on internet software and other topics</description>
	<lastBuildDate>Tue, 28 Jul 2009 22:57:25 +0000</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.7.1</generator>
	<item>
		<title>
		By: Alf Mikula		</title>
		<link>/2009/07/planning-xp/#comment-579</link>

		<dc:creator><![CDATA[Alf Mikula]]></dc:creator>
		<pubDate>Tue, 28 Jul 2009 22:57:25 +0000</pubDate>
		<guid isPermaLink="false">/?p=1862#comment-579</guid>

					<description><![CDATA[In response to your first question, I&#039;ve struggled with this one myself.  Obviously if you can&#039;t control how many engineer-hours go into the product, fixed iteration length is a little harder to deal with.  I think in this case you either 1) Pick a constant size estimate (use something like story point estimation and planning poker) and close the iteration when the work is done, or 2) Pick a constant iteration length and release what you have at the time.

As for effective ways to deal with unknowns, I like to use story point estimation with Fibonacci values (1,3,5,8,13) and bump up the estimate (3 -&#062; 5, 5 -&#062; 8) when there&#039;s a minor unknown, to compensate.  If there&#039;s a major unknown, we try to defer the story and allocate time for research/planning like you suggest.]]></description>
			<content:encoded><![CDATA[<p>In response to your first question, I&#8217;ve struggled with this one myself.  Obviously if you can&#8217;t control how many engineer-hours go into the product, fixed iteration length is a little harder to deal with.  I think in this case you either 1) Pick a constant size estimate (use something like story point estimation and planning poker) and close the iteration when the work is done, or 2) Pick a constant iteration length and release what you have at the time.</p>
<p>As for effective ways to deal with unknowns, I like to use story point estimation with Fibonacci values (1,3,5,8,13) and bump up the estimate (3 -&gt; 5, 5 -&gt; 8) when there&#8217;s a minor unknown, to compensate.  If there&#8217;s a major unknown, we try to defer the story and allocate time for research/planning like you suggest.</p>
]]></content:encoded>
		
			</item>
		<item>
		<title>
		By: Jamie Flournoy		</title>
		<link>/2009/07/planning-xp/#comment-578</link>

		<dc:creator><![CDATA[Jamie Flournoy]]></dc:creator>
		<pubDate>Tue, 28 Jul 2009 22:44:05 +0000</pubDate>
		<guid isPermaLink="false">/?p=1862#comment-578</guid>

					<description><![CDATA[I consider myself an XP apprentice on the cusp of becoming a journeyman, definitely not an expert but not a n00b either. :)
So here are my thoughts:

Question 1 (variable scheduling): If you estimate user story effort in terms of pair-half-days = 1 point, then you should be able to use that against the fluctuating schedule of the team to guesstimate how many points/week your velocity will be. If you actually can&#039;t predict when your team will work at all, then estimation seems to me to be impossible. In that case maybe you just decide that each iteration ends after 10 points or 2 weeks, whichever comes first.

Question 2: If possible the customer should be included in planning meetings so you can have that conversation in real time. You should also have a list of upcoming, roughly prioritized future stories so that you can look ahead and see whether your higher-effort design is going to save you time.

See also my blog post on &quot;lazy YAGNI&quot;: http://www.pervasivecode.com/blog/2009/05/30/xp-experiences-part-2-of-5/

Question 3: I have found nothing at all about UI design in particular in XP writings. I prefer to assume that this is part of what is means by XP &quot;design&quot; along with the more obvious code &#038; DB design. You do design when it seems necessary. Avoiding the misinterpretation of YAGNI as &quot;lazy YAGNI&quot; helps here too: if you know what features are coming up 2-3 months from now, that helps you design a UI now that will have a logical place for the future features to fit into.

Hope this helps!]]></description>
			<content:encoded><![CDATA[<p>I consider myself an XP apprentice on the cusp of becoming a journeyman, definitely not an expert but not a n00b either. :)<br />
So here are my thoughts:</p>
<p>Question 1 (variable scheduling): If you estimate user story effort in terms of pair-half-days = 1 point, then you should be able to use that against the fluctuating schedule of the team to guesstimate how many points/week your velocity will be. If you actually can&#8217;t predict when your team will work at all, then estimation seems to me to be impossible. In that case maybe you just decide that each iteration ends after 10 points or 2 weeks, whichever comes first.</p>
<p>Question 2: If possible the customer should be included in planning meetings so you can have that conversation in real time. You should also have a list of upcoming, roughly prioritized future stories so that you can look ahead and see whether your higher-effort design is going to save you time.</p>
<p>See also my blog post on &#8220;lazy YAGNI&#8221;: <a href="http://www.pervasivecode.com/blog/2009/05/30/xp-experiences-part-2-of-5/" rel="nofollow ugc">http://www.pervasivecode.com/blog/2009/05/30/xp-experiences-part-2-of-5/</a></p>
<p>Question 3: I have found nothing at all about UI design in particular in XP writings. I prefer to assume that this is part of what is means by XP &#8220;design&#8221; along with the more obvious code &amp; DB design. You do design when it seems necessary. Avoiding the misinterpretation of YAGNI as &#8220;lazy YAGNI&#8221; helps here too: if you know what features are coming up 2-3 months from now, that helps you design a UI now that will have a logical place for the future features to fit into.</p>
<p>Hope this helps!</p>
]]></content:encoded>
		
			</item>
	</channel>
</rss>
