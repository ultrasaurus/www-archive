<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>the evolving ultrasaurus</title>
	<atom:link href="/feed/" rel="self" type="application/rss+xml" />
	<link></link>
	<description>Sarah Allen&#039;s reflections on internet software and other topics</description>
	<lastBuildDate>Sat, 04 Jul 2020 10:47:06 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.7.1</generator>
	<item>
		<title>hope is not a strategy</title>
		<link>/2020/07/hope-is-not-a-strategy/</link>
					<comments>/2020/07/hope-is-not-a-strategy/#respond</comments>
		
		<dc:creator><![CDATA[sarah]]></dc:creator>
		<pubDate>Sat, 04 Jul 2020 10:46:13 +0000</pubDate>
				<category><![CDATA[Uncategorized]]></category>
		<guid isPermaLink="false">/?p=7019</guid>

					<description><![CDATA[&#8220;Yeah I think I got to the limit of my bargaining &#8230; getting to end of May, and when I didn’t seem to get past my last best day which was 2 weeks ago&#8221; It was May 25th, the day I remember grieving for my lost life, text chatting with my flu buddy about the&#8230; <a href="/2020/07/hope-is-not-a-strategy/">Continue reading <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<p>&#8220;Yeah I think I got to the limit of my bargaining &#8230; getting to end of May, and when I didn’t seem to get past my last best day which was 2 weeks ago&#8221; It was May 25th, the day I remember grieving for my lost life, text chatting with my <em>flu buddy</em> about the five stages of grief: denial, anger, bargaining, depression and acceptance.</p>
<p>&#8220;I think the thing is that I have to learn to live with this — I can’t just keep expecting, waiting to suddenly get better.&#8221; I stopped making plans beyond &#8220;rest, walk a little, rest, eat a little, rest&#8230;&#8221; in achingly slow motion, on a good day I could send an email <em>and</em> talk on the phone to a friend.</p>
<p>It&#8217;s not that I gave up hope, it&#8217;s just that thinking about any specific hope for the future was just not helpful. Recently, my brother shared a poem that captured this experience well:</p>
<p>My grandmother once gave me a tip:<br />
In difficult times, you move forward in small steps.<br />
Do what you have to do, but little by little.<br />
Don&#8217;t think about the future, or what may happen tomorrow.<br />
Wash the dishes.<br />
Remove the dust.<br />
Write a letter.<br />
Make a soup.<br />
You see?<br />
You are advancing step by step.<br />
Take a step and stop.<br />
Rest a little.<br />
Praise yourself.<br />
Take another step.<br />
Then another.<br />
You won&#8217;t notice, but your steps will grow more and more.<br />
And the time will come when you can think about the future without crying.</p>
<p>&#8212; Elena Mikhalkova, <em>The Room of Ancient Keys</em></p>
<p>I couldn&#8217;t find anything else written by Elena Mikhalkova that has been translated into English. I&#8217;d love to hear about it if her books or any of her other poems is ever translated.</p>
]]></content:encoded>
					
					<wfw:commentRss>/2020/07/hope-is-not-a-strategy/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>duck typing in rust: trait vs type</title>
		<link>/2020/01/duck-typing-in-rust-trait-vs-type/</link>
					<comments>/2020/01/duck-typing-in-rust-trait-vs-type/#respond</comments>
		
		<dc:creator><![CDATA[sarah]]></dc:creator>
		<pubDate>Sat, 25 Jan 2020 22:33:23 +0000</pubDate>
				<category><![CDATA[code]]></category>
		<guid isPermaLink="false">/?p=7004</guid>

					<description><![CDATA[A Trait in the Rust programming language enables what today&#8217;s coders commonly call &#8220;duck-typing&#8221; (walks like a duck and quacks like a duck). In Rust, type refers to concrete types &#8212; the type of a value; whereas, a Trait refers to an abstract or generic type. Here the English word type lacks the specificity we&#8230; <a href="/2020/01/duck-typing-in-rust-trait-vs-type/">Continue reading <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<p>A <code>Trait</code> in the Rust programming language enables what today&#8217;s coders commonly call &#8220;duck-typing&#8221; (walks like a duck and quacks like a duck).</p>
<p>In Rust, <code>type</code> refers to concrete types &#8212; the type of a value; whereas, a <code>Trait</code> refers to an abstract or generic type. Here the English word <em>type</em> lacks the specificity we need to describe these concepts, so we need adjectives to differentiate.</p>
<h2>TLDR: traits vs types</h2>
<p>The <code>type</code> keyword lets us define a type alias, like:</p>
<pre><code>type Population = i32;
</code></pre>
<p>This is useful if I&#8217;m often passing around specific variables for a Population, and I have function that takes multiple numbers, then the compiler will be able to  catch certain classes of errors:</p>
<pre><code>fn report(p: Population, num: i32)
</code></pre>
<p>A Trait is a collection of functions that can be applied to a type (a built-in type, like <code>i32</code> or a type that we have defined with a struct, enum or type alias). A good example of a Trait is <a href="https://doc.rust-lang.org/std/string/trait.ToString.html#tymethod.to_string">ToString</a> which is part of the Rust standard library:</p>
<pre><code>pub trait ToString {
    fn to_string(&amp;self) -&gt; String;
}
</code></pre>
<p>Here&#8217;s a naive approach to implementing ToString on a custom struct:</p>
<pre><code>struct Monster {
  eyeball_count: i32,
}

impl ToString for Monster {
  fn to_string(&amp;self) -&gt; String {
    format!("{}-eyed {}", self.eyeball_count, "monster")
  }
}

fn main() {
  let m = Monster { eyeball_count: 3 };
  println!("We just created a {}!", m.to_string())
}
</code></pre>
<p>Experienced Rustaceans would rarely implement the above code, instead they might implement <a href="https://doc.rust-lang.org/std/fmt/trait.Display.html">std::fmt::Display</a> which provides additional functionality we probably want, so if I write this instead of <code>impl ToString for Monster</code>:</p>
<pre><code>impl fmt::Display for Monster {
  fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
    write!(f, "{}-eyed {}", self.eyeball_count, "monster")
  }
}
</code></pre>
<p>Then our code that calls <code>to_string</code> will still work, but we can also provide the variable directly to println! (or format!) and it will also work:</p>
<pre><code>  println!("We just created a {}!", m);
</code></pre>
<p>This is because Rust allows for implementing functions on Traits in terms of a generic type.</p>
<h2>Traits in context</h2>
<p>Traits help break down what&#8217;s needed and make our code reusable and easier to maintain. Most libraries will use many Traits from the std libary, as well as their own Traits, which can make the learning curve a bit steep, but very flexible once you understand what they do.</p>
<p>So, as I&#8217;m learning, it helps me to spell everything out, but then I end up with code that was a bit hard to read. Check out this beauty that I wrote yesterday:</p>
<pre><code>async fn read_some&lt;R: AsyncRead + Send + Unpin&gt;(mut reader: R) -&gt; Result&lt;(), std::io::Error&gt;
</code></pre>
<p>I&#8217;m using Rust 1.39 with built-in <code>async fn</code> which means that the compiler will build me a future and I can declare as the return value to be whatever type that Future will ultimately produce (or simply what my function returns). In this case, I want to be able to pass in a <a href="https://docs.rs/tokio/0.2.10/tokio/net/struct.TcpStream.html">tokio::net::TcpStream</a> and also a &#8220;ReadHalf&#8221; that is returned from <a href="https://docs.rs/tokio/0.2.10/tokio/io/fn.split.html">split</a>.</p>
<p>My first attempt at refactoring was to do this:</p>
<pre><code>type Reader = AsyncRead + Send + Unpin;
</code></pre>
<p>The above code doesn&#8217;t do what I wanted. I&#8217;ve explained above that <code>type</code> creates an alias for a concrete type; however, when we provide Traits, it (unexpected for me) creates a &#8220;Trait object&#8221; which is not the abstract type I was looking for. What I wanted to do was to define a new Trait that composes the other traits, but has no implementation of its own.  Here&#8217;s the syntax I was looking for:</p>
<pre><code>trait Reader: AsyncRead + Send + Unpin { } 
impl&lt;T: AsyncRead + Send + Unpin&gt; Reader for T {}
</code></pre>
<p>which I can then use like this:</p>
<pre><code>async fn read_some&lt;R: Reader&gt;(mut reader: R) -&gt; Result&lt;(), std::io::Error&gt;
</code></pre>
<p>or in a slightly more readable form with <code>where</code>:</p>
<pre><code>async fn read_some&lt;R&gt;(mut reader: R) -&gt; Result&lt;(), std::io::Error&gt;
where R: AsyncReader  
</code></pre>
<p>If you want to see the working code, I have a few examples here: https://github.com/ultrasaurus/rust-tokio-proxy where each can be executed like this: <code>cargo run --example reader-type</code></p>
<hr />
<p>Many thanks to the Alice, David, Lucio and Jeb on Tokio discord who helped me understand types, traits and how they are used in tokio!</p>
]]></content:encoded>
					
					<wfw:commentRss>/2020/01/duck-typing-in-rust-trait-vs-type/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>writing c library in rust</title>
		<link>/2020/01/writing-c-library-in-rust/</link>
					<comments>/2020/01/writing-c-library-in-rust/#respond</comments>
		
		<dc:creator><![CDATA[sarah]]></dc:creator>
		<pubDate>Thu, 16 Jan 2020 06:36:12 +0000</pubDate>
				<category><![CDATA[code]]></category>
		<guid isPermaLink="false">/?p=6995</guid>

					<description><![CDATA[I want to write a library in Rust that can be called from C and just as easily called from Rust code. The tooling makes it pretty easy, but I had to look in a few places to figure how it is supposed to work and get tests running in both languages. C library To&#8230; <a href="/2020/01/writing-c-library-in-rust/">Continue reading <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<p>I want to write a library in Rust that can be called from C and just as easily called from Rust code.  The tooling makes it pretty easy, but I had to look in a few places to figure how it is supposed to work and get tests running in both languages.</p>
<h1>C library</h1>
<p>To focus on the process of building and testing, the library will have a single function that adds two numbers.  I wrote it in pure C first:</p>
<p>lib.c</p>
<pre><code>int add(int a, int b) {
  return a + b;
}
</code></pre>
<p>lib.h</p>
<pre><code>int add(int a, int b);
</code></pre>
<p>main.c</p>
<pre><code>#include &lt;stdio.h&gt;
#include "lib.h"

int main() {
    int sum = add(1,2);
    printf("1 + 2 = %d\n", sum);
}
</code></pre>
<p>one-liner to compile and run the app</p>
<pre><code>gcc *.c -o app &amp;&amp; ./app
</code></pre>
<p>output: <code>1 + 2 = 3</code></p>
<p>then I wrote a simple automated test, based on <a href="https://eradman.com/posts/tdd-in-c.html">tdd blog post</a></p>
<h1>Rust library</h1>
<pre><code>cargo new add --lib
</code></pre>
<p>replace lib.rs with</p>
<pre><code>#[no_mangle]
pub extern "C" fn add(a: i32, b:i32) -&gt; i32 {
    a + b
}


#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        use crate::add;
        assert_eq!(add(2,2), 4);
    }
}
</code></pre>
<p>build and run with <code>cargo test</code><br />
which should have output like</p>
<pre><code>$ cargo test
    Finished dev [unoptimized + debuginfo] target(s) in 0.01s
     Running target/debug/deps/add-45abb08ccefdc53c

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests add

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<h2>Compile as static library</h2>
<p>Add to <code>Cargo.toml</code></p>
<pre><code>[lib]
name = "add"
crate-type = ["staticlib"]  
</code></pre>
<p>Now <code>cargo build</code> generates a compiled library file: <code>target/debug/libadd.a</code>.  I could have stopped there, but I expect to iterate on this a bit and I had read about a crate that generates the C header file&#8230;</p>
<h2>Generate a header (command-line)</h2>
<p>First, install the lovely <a href="https://github.com/eqrion/cbindgen">cbindgen</a> crate (using &#8211;force just to make sure everything is up to date with the latest):</p>
<pre><code>cargo install --force cbindgen
</code></pre>
<p>the command-line tool is pretty neat:</p>
<pre><code>touch cbindgen.toml    # can be empty for defaults
cbindgen --config cbindgen.toml --crate add --output add.h
</code></pre>
<p>The above command will generate &#8220;add.h&#8221; file at the root of the crate.</p>
<h2>Generate a header (cargo build)</h2>
<p>I prefer to have the header generation integrated with cargo build (or at least I think I will).  Here are the steps:</p>
<p>Add to <code>Cargo.toml</code>:</p>
<pre><code>[build-dependencies]
cbindgen = "0.12"
</code></pre>
<p>By default, the header file is buried in <code>target/debug/build/add-...</code> with a bunch of intermediary build files.  I find that it is nice to put it at the root of my crate where it is easy to find. Below is a custom build file that puts it in the crate root (aka <code>CARGO_MANIFEST_DIR</code>, the directory that <code>Cargo.toml</code> is in).</p>
<p>build.rs:</p>
<pre><code>extern crate cbindgen;

use std::env;
use std::path::PathBuf;


fn main() {
  let crate_dir = PathBuf::from(env::var("CARGO_MANIFEST_DIR")
        .expect("CARGO_MANIFEST_DIR env var is not defined"));

  let config = cbindgen::Config::from_file("cbindgen.toml")
        .expect("Unable to find cbindgen.toml configuration file");

  cbindgen::generate_with_config(&amp;crate_dir, config)
        .expect("Unable to generate bindings")
        .write_to_file(crate_dir.join("add.h"));
}
</code></pre>
<p>As mentioned above, <code>cbindgen.toml</code> may be empty, but here&#8217;s some settings I like:</p>
<pre><code>include_guard = "add_h"
autogen_warning = "/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */"
language = "C"
includes = []
sys_includes = ["stdint.h"]
no_includes = true   
</code></pre>
<p>Confusingly <code>no_includes</code> means no <em>extra</em> includes.  I prefer to have only the ones that I know are needed, rather than some random list of &#8220;common&#8221; headers.</p>
<p>Here&#8217;s my generated header:</p>
<pre><code>#ifndef add_h
#define add_h

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include &lt;stdint.h&gt;

int32_t add(int32_t a, int32_t b);

#endif /* add_h */
</code></pre>
<h2>Putting it all together</h2>
<p>Example <code>main.c</code> in the root of the crate:</p>
<pre><code>#include &lt;stdio.h&gt;
#include "add.h"

int main() {
    int sum = add(1,2);
    printf("1 + 2 = %d\n", sum);
}
</code></pre>
<p>compile and run:</p>
<pre><code>gcc main.c add/target/debug/libadd.a -o app &amp;&amp; ./app
</code></pre>
<p>outputs: <code>1 + 2 = 3</code></p>
<p>This make me unreasonably happy.  Rust syntax can be a bit finicky and certainly takes a bit of getting used, but this kind of tooling could more than make up for that in accelerating the dev cycle.</p>
<p>For the full applications with a mini test suite in C, see <a href="https://github.com/ultrasaurus/rust-clib/tree/v0.1">github/ultrasaurus/rust-clib</a> &#8212; the v0.1 branch is from when this blog post was written.</p>
]]></content:encoded>
					
					<wfw:commentRss>/2020/01/writing-c-library-in-rust/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>rust on heroku with hyper http</title>
		<link>/2020/01/rust-on-heroku-with-hyper-http/</link>
					<comments>/2020/01/rust-on-heroku-with-hyper-http/#respond</comments>
		
		<dc:creator><![CDATA[sarah]]></dc:creator>
		<pubDate>Mon, 06 Jan 2020 02:39:54 +0000</pubDate>
				<category><![CDATA[code]]></category>
		<guid isPermaLink="false">/?p=6984</guid>

					<description><![CDATA[Running an app on heroku requires at least one entry point responding to http. An easy way to do this is to use hyper to create a simple web service. Setup cargo new hello_rust --bin cd hello_rust git init git add . git commit -m "cargo new hello_rust --bin" add to Cargo.toml: [dependencies] hyper =&#8230; <a href="/2020/01/rust-on-heroku-with-hyper-http/">Continue reading <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<p>Running an app on heroku requires at least one entry point responding to http.  An easy way to do this is to use <a href="hyper.rs">hyper</a> to create a simple web service.</p>
<h2>Setup</h2>
<pre><code>cargo new hello_rust --bin
cd hello_rust
git init
git add .
git commit -m "cargo new hello_rust --bin"
</code></pre>
<p>add to <code>Cargo.toml</code>:</p>
<pre><code>[dependencies]
hyper = "0.13"
</code></pre>
<h2>Web service code</h2>
<p>The core code to set up a little web service has a few key parts:</p>
<ol>
<li>the service (<code>async fn hello</code>)
<ul>
<li>an async function that takes a <code>hyper::Request</code> and returns a <code>hyper::Response</code> in the <code>Result</code></li>
<li><a href="https://docs.rs/hyper/0.13.1/hyper/struct.Request.html">Request</a> is generic over the Body, so it seems nifty to be able to provide our own Rust types for specific content (like JSON) and also for validating API POST params </li>
<li>Result is <a href="https://doc.rust-lang.org/std/convert/enum.Infallible.html">Infallible</a>: a Rust error type signifying that the function never returns an error</li>
</ul>
</li>
<li><a href="https://docs.rs/hyper/0.13.1/hyper/service/fn.make_service_fn.html">make_service_fn</a> &#8212; docs are a bit sparse on this, but I think all it does it generate an instance of the service with the Request context that so that each request can run concurrently</li>
<li>Server::bind(&amp;addr).serve(&#8230;) &#8212; Hyper uses a builder pattern where Server::bind generates a <a href="https://docs.rs/hyper/0.13.1/hyper/server/struct.Builder.html">Builder</a>, where you can configure http1/2 support and then a running instance of the Server is created by calling the <a href="https://docs.rs/hyper/0.13.1/hyper/server/struct.Builder.html#method.serve">serve method</a> with the service function.   </li>
</ol>
<p>To see this in action, replace <code>main.rs</code> with this code:</p>
<pre><code>use hyper::service::{make_service_fn, service_fn};
use hyper::{Body, Request, Response, Server};
use std::convert::Infallible;

async fn hello(_req: Request&lt;Body&gt;) -&gt; Result&lt;Response&lt;Body&gt;, Infallible&gt; {
    Ok(Response::new(Body::from(
        "&lt;HTML&gt;&lt;H1&gt;Hello World!&lt;/H1&gt;&lt;HTML&gt;",
    )))
}

#[tokio::main]
pub async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error + Send + Sync&gt;&gt; {

    let make_svc = make_service_fn(|_conn| {
        async { Ok::&lt;_, Infallible&gt;(service_fn(hello)) }
    });

    let addr = ([0, 0, 0, 0], 3000).into();

    let server = Server::bind(&amp;addr).serve(make_svc);

    println!("Listening on {}", addr);

    server.await?;

    Ok(())
}
</code></pre>
<p>to run the app locally:</p>
<pre><code>cargo run
</code></pre>
<p>then in the browser, go to <a href="http://localhost:3000/">http://localhost:3000/</a></p>
<h2>Heroku setup</h2>
<h3>1. Heroku CLI</h3>
<p>Install <a href="https://devcenter.heroku.com/articles/heroku-cli">heroku CLI</a> or if you already have it:</p>
<p><code>heroku update</code></p>
<p>Then to set up the app on heroku:</p>
<pre><code>heroku create --buildpack emk/rust
</code></pre>
<h3>2. Procfile</h3>
<p>Add a Procfile for heroku to know what to call when it receives a web request:</p>
<pre><code>echo "web: ./target/release/hello_rust" &gt;&gt; Procfile
</code></pre>
<h3>3. Port configuration</h3>
<p>Heroku requires that we listen on the port specified with the <code>PORT</code> env var.  So, add the following code and replace the hard-coded port number with this variable:</p>
<pre><code>    let port = env::var("PORT")
        .unwrap_or_else(|_| "3000".to_string())
        .parse()
        .expect("PORT must be a number");
</code></pre>
<h3>4. Deploy!</h3>
<p>Deploy the app by pushing code to the Heroku remote repository that was set up by the CLI in step 1.</p>
<pre><code> git push heroku master
</code></pre>
<p>Full code for the app is on <a href="https://github.com/ultrasaurus/hello-heroku-rust/tree/hyper">github.com/ultrasaurus/hello-heroku-rust</a></p>
<h2>Background</h2>
<p>My environment info (<code>rustup show</code>):</p>
<pre><code>stable-x86_64-apple-darwin (default)
rustc 1.39.0 (4560ea788 2019-11-04)
</code></pre>
]]></content:encoded>
					
					<wfw:commentRss>/2020/01/rust-on-heroku-with-hyper-http/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>rust on heroku with async/await and tokio</title>
		<link>/2020/01/rust-on-heroku-with-async-await-and-tokio/</link>
					<comments>/2020/01/rust-on-heroku-with-async-await-and-tokio/#respond</comments>
		
		<dc:creator><![CDATA[sarah]]></dc:creator>
		<pubDate>Sun, 05 Jan 2020 04:27:25 +0000</pubDate>
				<category><![CDATA[code]]></category>
		<guid isPermaLink="false">/?p=6975</guid>

					<description><![CDATA[In an effort to understand the new Rust async/await syntax, I made a super-simple app that simply responds to all HTTP requests with Hello! and deployed on Heroku. Update: If you just want to create a webservice in Rust and deploy on Heroku, I recommend next blog post: rust on heroku with hyper http. This&#8230; <a href="/2020/01/rust-on-heroku-with-async-await-and-tokio/">Continue reading <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<p>In an effort to understand the new Rust async/await syntax, I made a super-simple app that simply responds to all HTTP requests with <strong>Hello!</strong> and deployed on <a href="https://www.heroku.com/">Heroku</a>.</p>
<p>Update: If you just want to create a webservice in Rust and deploy on Heroku, I recommend next blog post: <a href="/2020/01/rust-on-heroku-with-hyper-http/">rust on heroku with hyper http</a>. This blog post focuses on the details of how the underlying request and response is handled with async/await, on <a href="https://blog.rust-lang.org/2019/11/07/Async-await-stable.html">stable Rust since 11/2019</a>.</p>
<p>The full source code and README instructions can be found on <a href="https://github.com/ultrasaurus/hello-heroku-rust/tree/tokio-only">github.com/ultrasaurus/hello-heroku-rust, tokio-only branch</a></p>
<h2>Rust &#8220;hello world&#8221; app</h2>
<p>Make a new project with cargo</p>
<pre><code>cargo new hello_rust --bin
cd hello_rust
git init
git add .
git commit -m “cargo new hello_rust —bin”

cargo run
</code></pre>
<p>output:</p>
<pre><code>   Compiling hello_rust v0.1.0 (/Users/sallen/src/rust/hello_rust)
    Finished dev [unoptimized + debuginfo] target(s) in 1.47s
     Running `target/debug/hello_rust`
Hello, world!
</code></pre>
<h2>Heroku setup</h2>
<p>Rust isn&#8217;t officially supported by Heroku yet, but there are lots of &#8220;buildpacks&#8221; which help to deploy a Rust app.  I picked <a href="https://github.com/emk/heroku-buildpack-rust">emk/heroku-buildpack-rust</a> &#8212; most stars, most forks &amp; recently updated!</p>
<p>We need the <a href="https://devcenter.heroku.com/articles/heroku-cli">heroku CLI</a>. I already had it and just did <code>heroku update</code> to sync to latest version (<code>7.35.1</code>).  Then to set up the app on heroku:</p>
<pre><code>heroku create --buildpack emk/rust
</code></pre>
<p>output provides a unique hostname by default:</p>
<pre><code>Creating app... done, ⬢ peaceful-gorge-05620
Setting buildpack to emk/rust... done
https://peaceful-gorge-05620.herokuapp.com/ | https://git.heroku.com/peaceful-gorge-05620.git
</code></pre>
<p>We need a Procfile so heroku knows our entrypoint</p>
<pre><code>echo "web: ./target/release/hello_rust" &gt;&gt; Procfile
</code></pre>
<h2>Write the app</h2>
<p>Add crate dependencies to <code>Cargo.toml</code> and add code to <code>main.rs</code> (and other files as with any Rust app).  The <em>emk/rust buildpack</em> takes care of building everything as part of the heroku deploy.</p>
<p>The following lines (in <code>Cargo.toml</code>) will add all of tokio features:</p>
<pre><code>[dependencies]
tokio = { version = "0.2", features = ["full"] }
</code></pre>
<p>I&#8217;d rather specify only what&#8217;s needed, but ran into something I couldn&#8217;t debug myself (<a href="https://github.com/tokio-rs/tokio/issues/2050">issue#2050</a>)</p>
<p>The core of the app accepts the sockets connections, but doesn&#8217;t read/write:</p>
<pre><code>use std::env;
use tokio::net::TcpListener;

#[tokio::main]
async fn main() {
    // Get the port number to listen on (required for heroku deployment).
    let port = env::var("PORT").unwrap_or_else(|_| "1234".to_string());

    let addr = format!("0.0.0.0:{}", port);
    let mut listener = TcpListener::bind(addr).await.unwrap();

    loop {
        println!("listening on port {}...", port);
        let result = listener.accept().await;
        match result {
            Err(e) =&gt; println!("listen.accept() failed, err: {:?}", e),
            Ok(listen) =&gt; {
                let (socket, addr) = listen;
                println!("socket connection accepted, {}", addr);
                println!("not doing anything yet");
            }
        }
    }
}
</code></pre>
<h2>Deploy on heroku</h2>
<p>The above code will build and deploy, by simply pushing the code to heroku:</p>
<pre><code>heroku push origin master
</code></pre>
<p>We can see what it is doing with <code>heroku logs --tail</code>:</p>
<p>Here&#8217;s where it starts the build and then kills the old app:</p>
<pre><code>2020-01-05T03:45:31.000000+00:00 app[api]: Build started by user ...
2020-01-05T03:45:50.450898+00:00 heroku[web.1]: Restarting
2020-01-05T03:45:50.454311+00:00 heroku[web.1]: State changed from up to starting
2020-01-05T03:45:50.244579+00:00 app[api]: Deploy 399e1c85 by user ...
2020-01-05T03:45:50.244579+00:00 app[api]: Release v24 created by user ...
2020-01-05T03:45:50.701533+00:00 heroku[web.1]: Starting process with command `./target/release/hello_rust`
2020-01-05T03:45:51.741040+00:00 heroku[web.1]: Stopping all processes with SIGTERM
2020-01-05T03:45:51.819864+00:00 heroku[web.1]: Process exited with status 143
</code></pre>
<p>Oddly, it seems to start the app before &#8220;State changed from starting to up&#8221; but it will fail if we&#8217;re not listening on the right port, so maybe that is as expected:</p>
<pre><code>2020-01-05T03:45:52.343368+00:00 app[web.1]: listening on port 49517...
2020-01-05T03:45:53.322238+00:00 heroku[web.1]: State changed from starting to up
2020-01-05T03:45:53.303486+00:00 app[web.1]: socket connection accepted, 10.171.202.59:17201
2020-01-05T03:45:53.303545+00:00 app[web.1]: not doing anything yet
2020-01-05T03:45:53.303619+00:00 app[web.1]: listening on port 49517...
2020-01-05T03:45:53.313259+00:00 app[web.1]: socket connection accepted, 172.17.146.217:43686
2020-01-05T03:45:53.313285+00:00 app[web.1]: not doing anything yet
2020-01-05T03:45:53.313370+00:00 app[web.1]: listening on port 49517...
2020-01-05T03:46:28.000000+00:00 app[api]: Build succeeded
2020-01-05T03:46:48.251168+00:00 heroku[router]: at=error code=H13 desc="Connection closed without response" method=GET path="/" host=peaceful-gorge-05620.herokuapp.com request_id=a0d630d9-790a-47db-87af-67e680b27907 fwd="69.181.194.59" dyno=web.1 connect=1ms service=1ms status=503 bytes=0 protocol=https
</code></pre>
<p>So, the first socket connection above is some internal heroku checker, then when I attempt to go to the app URL in the browser, it fails (as expected).</p>
<h2>Async read and write</h2>
<p>I tried to keep the code clear with as little <em>magic</em> as possible.  It&#8217;s a bit verbose (without even handling HTTP in any general way), but I found it helpful to see the details of read and write.</p>
<p>Note that adding <code>use tokio::prelude::*;</code> allows calling of <code>read_line</code> (defined in <code>tokio::io::AsyncBufReadExt</code>) and <code>write_all</code> (defined in <code>tokio::io::AsyncWriteExt</code>).<br />
The additional code reads the bytes from the socket line by line until we get the the end of the HTTP Request (signalled by a blank line).  So we look for two CLRFs (one at the end of the last header line and one for the blank line).</p>
<p><code>tokio::spawn(async move</code> makes it so sure we can read/write from one socket while also listening for additional connections. <code>tokio::spawn</code> will allow the program execution to continue, while concurrently allowing our async function <code>process_socket</code> to read and write from the socket.  Because we added <code>#[tokio::main]</code> above our <code>async fn main</code> entry point, tokio will set up an executor which will wait for all of our spawned tasks to complete before exiting.</p>
<pre><code>use std::env;
use tokio::net::TcpListener;
use tokio::prelude::*;

#[tokio::main]
async fn main() {
    // Get the port number to listen on (required for heroku deployment).
    let port = env::var("PORT").unwrap_or_else(|_| "1234".to_string());

    let addr = format!("0.0.0.0:{}", port);
    let mut listener = TcpListener::bind(addr).await.unwrap();

    loop {
        println!("listening on port {}...", port);
        let result = listener.accept().await;
        match result {
            Err(e) =&gt; println!("listen.accept() failed, err: {:?}", e),
            Ok(listen) =&gt; {
                let (socket, addr) = listen;
                println!("socket connection accepted, {}", addr);
                // Process each socket concurrently.
                tokio::spawn(async move {
                    let mut buffed_socket = tokio::io::BufReader::new(socket);
                    let mut request = String::new();
                    let mut result;
                    loop {
                        result = buffed_socket.read_line(&amp;mut request).await;
                        if let Ok(num_bytes) = result {
                            if num_bytes &gt; 0 &amp;&amp; request.len() &gt;= 4 {
                                let end_chars = &amp;request[request.len() - 4..];
                                if end_chars == "\r\n\r\n" {
                                    break;
                                };
                            }
                        }
                    }
                    if let Err(e) = result {
                        println!("failed to read from socket, err: {}", e);
                        return;
                    }
                    let html = "&lt;h1&gt;Hello!&lt;/h1&gt;";
                    println!("request: {}", request);
                    let response = format!(
                        "HTTP/1.1 200\r\nContent-Length: {}\r\n\r\n{}",
                        html.len(),
                        html
                    );
                    let write_result = buffed_socket.write_all(response.as_bytes()).await;
                    if let Err(e) = write_result {
                        println!("failed to write, err: {}", e);
                    }
                });
            }
        }
    }
}
</code></pre>
<h2>Background</h2>
<p>Here&#8217;s my environment info (<code>rustup show</code>):</p>
<pre><code>stable-x86_64-apple-darwin (default)
rustc 1.39.0 (4560ea788 2019-11-04)
</code></pre>
<p>Reference docs</p>
<ul>
<li>https://docs.rs/tokio/0.2.6/tokio/net/struct.TcpListener.html</li>
<li>https://docs.rs/tokio/0.2.6/tokio/net/struct.TcpStream.html</li>
<li>https://docs.rs/tokio/0.2.6/tokio/task/fn.spawn.html</li>
</ul>
]]></content:encoded>
					
					<wfw:commentRss>/2020/01/rust-on-heroku-with-async-await-and-tokio/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>patterns of actions are a making</title>
		<link>/2019/12/patterns-of-actions-are-a-making/</link>
					<comments>/2019/12/patterns-of-actions-are-a-making/#respond</comments>
		
		<dc:creator><![CDATA[sarah]]></dc:creator>
		<pubDate>Tue, 24 Dec 2019 20:27:17 +0000</pubDate>
				<category><![CDATA[general]]></category>
		<guid isPermaLink="false">/?p=6961</guid>

					<description><![CDATA[&#8220;There are things that you don’t even realize that you can do.&#8221; In a recent podcast, B. Mure tells about graphic facilitation: I didn’t really know it was a skill to have: to listen to people and very immediately draw something related to what they were talking about and present their ideas in a visual&#8230; <a href="/2019/12/patterns-of-actions-are-a-making/">Continue reading <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<p>&#8220;There are things that you don’t even realize that you can do.&#8221; In a <a href="http://makeitthentelleverybody.com/2019/12/b-mure/">recent podcast</a>, B. Mure tells about <em>graphic facilitation</em>:</p>
<blockquote><p>
  I didn’t really know it was a skill to have: to listen to people and very immediately draw something related to what they were talking about and present their ideas in a visual way.
</p></blockquote>
<p>Sometimes this is also called making &#8220;sketch notes.&#8221;  He goes on to talk about a general phenomenon where you discover that you can do a thing that you never thought was a thing:</p>
<blockquote><p>
  There are so many things that, if you are not given the opportunity, if somebody doesn’t see that within you, or thinks maybe you should just come along and try this thing that I’ve organized, there are things that you don’t even realize that you can do.
</p></blockquote>
<p>I think there are two parts of this that are transformational, that I&#8217;ve experienced myself and occasionally been able to spark in others.</p>
<ol>
<li><strong>Naming a pattern of actions</strong> or behavior: this is an act of creating that is rare and powerful. Discovering something is a skill that one can be good at and apply with intention is aided by that skill having a name.</li>
<li><strong>Recognizing the spark</strong> within someone else: seeing a capability, especially latent potential, within someone and naming it, inviting that person to experiment with a new skill, encouraging creative action in the world.</li>
</ol>
<p>There should be a word for the making of words that is more than coining a term, where the naming of a thing helps people do (or not do) whatever that is.</p>
<p>I&#8217;ve thought a lot about how the term <em>mansplaining</em> has helped a generation notice and often modify behavior. I learned about restorative justice as a framework for transforming guilt into responsibility. I remember when, at an early RailsBridge workshop, I applied lessons from my kid&#8217;s preschool to the challenge of how to teach without grabbing the keyboard (&#8220;Use your words&#8221;).</p>
<p>I love the idea of a word for a skill providing a path to developing that skill, connecting to a community, and finding paid work.</p>
<hr />
<p>The <a href="http://makeitthentelleverybody.com/2019/12/b-mure/">whole podcast</a> with Dan Berry and B. Mure is worth listening to for any creative folk or if you enjoy comics or visual storytelling and want a glimpse of that world.</p>
<p><img src="/wp-content/uploads/2019/12/bmuredraws-dot-com.png&quot;" alt="Image from website of B. Mure: the artist in sunshine looking skyward with arms spread wide upward in front of mountains and blue sky" /><br />
<a href="bmuredraws.com">https://bmuredraws.com/</a></p>
]]></content:encoded>
					
					<wfw:commentRss>/2019/12/patterns-of-actions-are-a-making/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>memory safety: necessary, not sufficient</title>
		<link>/2019/12/memory-safety-necessary-not-sufficient/</link>
					<comments>/2019/12/memory-safety-necessary-not-sufficient/#respond</comments>
		
		<dc:creator><![CDATA[sarah]]></dc:creator>
		<pubDate>Sun, 22 Dec 2019 22:33:28 +0000</pubDate>
				<category><![CDATA[Uncategorized]]></category>
		<guid isPermaLink="false">/?p=6933</guid>

					<description><![CDATA[As I think about developing new Internet-connected software, I worry about the safety of the people who use it. By 2021, most Web browsers won&#8217;t allow native code extensions, which will eliminate a lot of potential issues, while a hug swath of creative animations and interactives will disappear from the Web. I spent some time&#8230; <a href="/2019/12/memory-safety-necessary-not-sufficient/">Continue reading <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<p>As I think about developing new Internet-connected software, I worry about the safety of the people who use it. By 2021, most Web browsers won&#8217;t allow native code extensions, which will eliminate a lot of potential issues, while a hug swath of creative animations and interactives will disappear from the Web. I spent some time this summer, thinking about what I could learn from the security vulnerabilities in the Flash Player that has been much maligned in recent years.</p>
<h2>Flash CVEs (2001-2009)</h2>
<p>I looked at the Common Vulnerabilities and Exposure List (<a href="https://cve.mitre.org/data/downloads/index.html">CVE List</a> hosted by Mitre with all reports 2001-2019. I found 1172 Flash Player vulnerabilities, which sounds huge, but in context of vulnerabilities reported in Web Browsers, doesn&#8217;t look that bad:</p>
<ul>
<li>1172  Flash Player </li>
<li>1999  Internet Explorer </li>
<li>2033  Chrome </li>
<li>2442  Firefox</li>
</ul>
<p>Note: these numbers don&#8217;t necessarily tell us that Firefox had more vulnerabilities than Internet Explorer. It could mean that Firefox was more rigorously open in reporting vulnerabilities, which seems likely.</p>
<h2>Understanding attack vectors</h2>
<p>Vulnerabilities in the Flash Player were particularly dangerous because Flash was installed on all of the Web Browsers, so any flaw in Flash was much easier to exploit than a flaw in a specific Web Browser. To understand this, one needs to understand that the primary <a href="https://www.sumologic.com/glossary/attack-vector/">attack vector</a> enabling a hacker to take advantage of a vulnerability in Flash Player was to create a <em>malicious Flash application or movie</em> that would distract the user while doing something illicit or intentionally trigger a crash and then exploiting that crash to execute native code with access to the user&#8217;s machine.</p>
<p>In the larger context of a specific attack, a vulnerability in the Flash Player would typically need to be combined with something else:<br />
* deceptive emails (aka phishing)<br />
* deceptive websites<br />
* &#8220;man in the middle&#8221; attacks (replace real Web content with malicious content that appears identical)</p>
<h2>Categorizing vulnerabilities</h2>
<p>I conducted a rough cut analysis of matching terms by reading the list of CVEs and creating categories that might provide instructive value in thinking through how to avoid similar issues in the future.</p>
<p><img src="/wp-content/uploads/2019/12/flash-cve-categories.png" alt="pie chart illustrating data in table below" /></p>
<ul>
<li>802   memory safety</li>
<li>42    other code execution</li>
<li>58    XSS, CORS, CLRF</li>
<li>61    parsing / validation</li>
<li>13    clickjacking</li>
<li>91    bypass sandbox</li>
<li>105   other</li>
</ul>
<h3>Memory safety (~70%)</h3>
<p>The vast majority of issues (&#8220;memory safety&#8221;) resulted from coding errors, which can now be avoided with modern programming languages. For a long time, we&#8217;ve been able to use languages like Erlang/Elixir, Java, Python, Ruby, and Go for server-side coding with memory safety features. Even C++ has language features and libraries (though you must choose to use them).  Now, for low-profile client software we can use Rust or WebAssembly when we need something higher performance or less memory-hungry than JavaScript.</p>
<h3>Escaping the &#8220;sandbox&#8221; (~15%)</h3>
<p>If we develop code that runs in a Web browser, we can trust the browser&#8217;s &#8220;sandbox&#8221; &#8212; our apps can only use a restricted set of APIs.  If we&#8217;re writing a Web browser or any other Internet-connected software used by humans or machines, then it is a good idea to carefully isolate our code that can access the operating system to write files or make network calls.</p>
<p>From my CVE analysis, coding errors in this category resulted in just over 15% of CVEs (other code execution, bypassing sandbox, and XSS, CORS, CLRF issues). Of course, the biggest thing you can do is not include the code that does powerful things you don&#8217;t want to allow. However, sometimes you do need to load and execute a shared library, accessing the filesystem and the network.</p>
<h3>Parsing / Validation (~5% / ~15% excluding memory safety)</h3>
<p>Parsing and validation of input (mostly reading a file or parameter) is another common coding error pattern which can result in a serious vulnerability. Having to fix these kinds of issues causes me to be very careful when adding parsing code to any app or library.  If we exclude memory safety errors, parsing and validation errors are larger than any identified class of error.</p>
<p><img src="/wp-content/uploads/2019/12/pie-chart-excluding-memory-safety-1.png" alt="pie chart excluding memory safety shows 16% parsing / validation" /></p>
<h3>Clickjacking and &#8220;other&#8221;</h3>
<p>Clickjacking is noteworthy for anyone developing a client app with extensions where 3rd party developers (or other users via content sharing) can present information to the user and allow interaction. This class of attack uses features that are designed to empower users to present compelling content to be instead used to trick people into doing something unintended.  For example, there were bugs that allowed Flash content to overlay other web pages or browser UI, thereby tricking the user into clicking or typing in a way to provide privileged access.</p>
<p>Perhaps &#8220;other&#8221; deserves a closer look, but I didn&#8217;t find clear patterns and suspect that contains many smaller categories.</p>
<h2>Parsing is hard</h2>
<p>In my experience, many programmers recognize that implementing an extension mechanism that allows for user interaction or providing a &#8220;sandbox&#8221; for 3rd party code can be very tricky to get right and will exercise great care in writing or using that kind of code.  However, I have often interacted with programmers who don&#8217;t seem to believe that writing code to parse text is difficult. Writing code that performs the intended action is not hard, but writing code that has no unintended effects requires very careful coding and a little imagination.</p>
<p>Looking toward open source code for some examples to learn from, here are a few examples of URL parsing libraries where bugs were found (and fixed) after vulnerabilities were discovered in the field:</p>
<ul>
<li>https://github.com/envoyproxy/envoy/issues/7728 (Envoy proxy)</li>
<li>https://go-review.googlesource.com/c/go/+/189258/ (Go)</li>
<li>https://www.cvedetails.com/cve/CVE-2018-3774/ (url-parse Node library)</li>
</ul>
<hr />
<p>The results of this analysis were included as part of Code Mesh LDN 19 talk, A landscape of unintended consequences (<a href="https://www.youtube.com/watch?v=pcuNby-MxCo">video</a>, <a href="https://www.slideshare.net/sarah.allen/internet-security-a-landscape-of-unintended-consequences">slides</a>). The data and methodology is available at on github: <a href="https://github.com/ultrasaurus/flash-cve-analysis">ultrasaurus/flash-cve-analysis</a>.</p>
]]></content:encoded>
					
					<wfw:commentRss>/2019/12/memory-safety-necessary-not-sufficient/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>brief history of rtmp + future thoughts</title>
		<link>/2019/12/brief-history-of-rtmp-future-thoughts/</link>
					<comments>/2019/12/brief-history-of-rtmp-future-thoughts/#respond</comments>
		
		<dc:creator><![CDATA[sarah]]></dc:creator>
		<pubDate>Tue, 17 Dec 2019 01:47:02 +0000</pubDate>
				<category><![CDATA[Uncategorized]]></category>
		<guid isPermaLink="false">/?p=6922</guid>

					<description><![CDATA[RTMP: web video innovation or Web 1.0 hack… how did we get to now? (Demuxed 2019) It was fun to go back in time and recall why Flash was great in 2000, when IE 5.5 had just been released and you couldn&#8217;t rely on CSS actually working. In prepping for this talk, I worked really&#8230; <a href="/2019/12/brief-history-of-rtmp-future-thoughts/">Continue reading <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<p><strong>RTMP: web video innovation or Web 1.0 hack… how did we get to now?</strong> (Demuxed 2019)</p>
<p><iframe loading="lazy" width="770" height="433" src="https://www.youtube.com/embed/5Rv50RCwqo8?feature=oembed" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></p>
<p>It was fun to go back in time and recall why Flash was great in 2000, when IE 5.5 had just been released and you couldn&#8217;t rely on CSS actually working.  In prepping for this talk, I worked really hard to try to express what Web development was like then and why people loved Flash: &#8220;200K of cross-platform goodness.&#8221; Flash made the Web work for high fidelity interactive graphics 20 years ago, which I think helped drive Web standards to support more than text, images and links.</p>
<p>&#8220;We wanted to support all the people on the internet.&#8221; It still boggles my mind how we could support low-latency way-back-then and now when computers and networks are faster it seems impossible&#8230; sometimes I try to visualize what is happening to the bits as I wait for something to happen. (I really do know why things are slower now, and it&#8217;s not just about the tech, but that&#8217;s a different story.)</p>
<p>HTTP tunneling worked much better than you would expect&#8230; sometimes it&#8217;s good to make something work for everyone, even if not optimal.</p>
<p>I fondly remembering Doug Engelbart telling me that his Augment system (built in the 1960s) had more features than Flash Player 6 + Flash Communication Server in 2002.  (It&#8217;s great when your heroes tell you that your great accomplishments are not all that interesting.) Later, he did acknowledge that making this stuff available to everyone on the Web was &#8220;pretty good.&#8221; Inspiring widespread adoption, creating an ecosystem is a different kind of innovation.</p>
<p>The thing that makes it an ecosystem is that each essential component can be bought from multiple companies and is available as open source. At first Flash was essential, now much later, Flash doesn&#8217;t really matter anymore to the relevance of the RTMP protocol.</p>
<p>Today there are 500M IP camera on the Internet, about the number of people on the Web when Flash Player 6 was released. SmartHome video sensors have insane growth. The future of video is not about how to catch up with latency and resolution of live broadcast TV (though that will happen), it&#8217;s about how we can be integrate video streams from new devices, how we can help the machines help the people by creating new applications.  Maybe RTMP will be a part of that, what do you think?</p>
]]></content:encoded>
					
					<wfw:commentRss>/2019/12/brief-history-of-rtmp-future-thoughts/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>rust 2020: fulfill the promise</title>
		<link>/2019/12/rust-2020/</link>
					<comments>/2019/12/rust-2020/#respond</comments>
		
		<dc:creator><![CDATA[sarah]]></dc:creator>
		<pubDate>Sun, 01 Dec 2019 09:37:16 +0000</pubDate>
				<category><![CDATA[general]]></category>
		<guid isPermaLink="false">/?p=6885</guid>

					<description><![CDATA[As a newcomer to Rust, my suggestion for 2020 theme is to fulfill the promise of &#8220;empowering everyone to build reliable and efficient software&#8221; by finishing what&#8217;s started (rather than adding new features), continuing the focus on good docs and good tools, and expanding to develop a coherent ecosystem. Rust empowers you to reach farther,&#8230; <a href="/2019/12/rust-2020/">Continue reading <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<p>As a newcomer to Rust, my suggestion for 2020 theme is to fulfill the promise of &#8220;empowering everyone to build reliable and efficient software&#8221; by finishing what&#8217;s started (rather than adding new features), continuing the focus on good docs and good tools, and expanding to develop a coherent ecosystem.</p>
<blockquote><p>
  Rust empowers you to reach farther, to program with confidence in a wider variety of domains than you did before. &#8212; <a href="https://doc.rust-lang.org/book/foreword.html">Rust Language Book forward</a>
</p></blockquote>
<h2>Overview themes</h2>
<p>2020 roadmap: finish what&#8217;s started, fulfill the promise</p>
<p>2021 edition: scalability &#8211; Can newcomers to Rust create a real-world, complex system without recreating basic components or contributing to the language itself?</p>
<ul>
<li>more scalable systems written in Rust</li>
<li>experienced C/C++ engineers can easily transition to Rust</li>
<li>more scalable ecosystem
<ul>
<li>commonly needed libraries are available</li>
<li>new engineers can easily become contributors</li>
</ul>
</li>
</ul>
<h2>Keep doing</h2>
<ul>
<li>Tooling is great! rustup toolchain, feature flags, online/offline docs make it easy to experiment with new Rust/crate features, even as a relatively new Rust programmer. </li>
<li>Transparency (like this call for blog posts, RFC process including roadmap)</li>
<li>Focus on good docs &amp; good error reporting is incredibly helpful. Keep iterating on this!</li>
</ul>
<h2>Feature requests</h2>
<ul>
<li>safety beyond memory safety and concurrency. For example: URL parsing should <strike>be in std</strike> have a shared implementation that supports common use cases &#8212; it&#8217;s risky for Internet apps to not have a stable, well vetted URL parser, why are there three? (That&#8217;s a rhetorical question. I know why, but don&#8217;t think there need to be.  See <a href="https://twitter.com/NikolaiVazquez/status/1149063581226295297">twitter discussion</a> [Update 12/16/2019: I&#8217;d like to see convergence in URL parsers (or perhaps a shared common library) the way the community seems to be converging around <a href="https://serde.rs/">serde</a>.]</li>
<li>async all the things! I think this is already the plan. I look forward to async I/O (network and files) to be supported in the std library. I appreciate the thoughtfulness about safety, factoring out useful core concepts (like Pin/Task), and ensuring compatibility with Futures and Tokio crates. Consider other async use cases: GPU, OpenGL</li>
<li>lifetimes visualization would accelerate learning curve on resolving compiler errors, good ideas in <a href="https://twitter.com/ultrasaurus/status/1183136267208232961">this thread</a></li>
</ul>
<h2>Slow down to speed up</h2>
<p>In my experience writing documentation often uncovers design issues and bugs. <a href="https://github.com/rust-lang/rfcs/blob/master/0000-template.md">RFC template</a> has a <strong>guide-level explanation</strong> section, which is great, and taking that one step further to writing baseline docs before declaring a feature &#8220;stable&#8221; would create positive pressure for community focus. Some ideas for process improvements&#8230;</p>
<ul>
<li>A crisp &#8220;definition of done&#8221; could help focus the community. Consider adding requirements to releasing &#8216;stable&#8217;
<ul>
<li>RFC updated to reflect what was completed and is still open</li>
<li>stable reference docs are complete or include link to RFC</li>
</ul>
</li>
<li>Consider WIP limits: <a href="https://leankit.com/learn/kanban/how-to-use-wip-limits-to-increase-speed/">how limiting work-in-progress increases speed</a></li>
</ul>
<p>It seems in keep with Rust values to create a strong incentive to support contributing writers who are working to take the feature over-the-line and encourage new engineers to contribute. It is easier for new contributors to work with APIs that are documented or clearly dive into a work-in-progress, aware that they are contributing to finishing something.</p>
<h2>Other Improvements</h2>
<ul>
<li>Documentation shouldn&#8217;t require deep knowledge of Rust (example: https://stackoverflow.com/questions/56402818/how-do-i-interpret-the-signature-of-read-until-and-what-is-asyncread-bufread-i/56403568#56403568)</li>
</ul>
<h2>Background</h2>
<p>The reason I&#8217;m learning Rust is that I am experienced engineer with a need to write performant, low-profile client/server code. I&#8217;m excited about the idea of writing one body of code that can (potentially) work across native desktop, mobile, servers&#8230; and with cross-compilation to WebAssembly (Wasm), also browsers and edge servers.</p>
<p>Arguably, C works for all my needs, it even cross-compiles to Wasm.  I want to like Rust better. I do in theory, but in practice, it&#8217;s got a lot of sharp edges (which is saying a lot when comparing it to C).</p>
<hr />
<p>Updated Dec 2019 to modify the introduction, so excerpt is useful (if <a href="https://readrust.net/rust-2020">rust2020 summary post</a> is ever updated.  Original text below:</p>
<p>answering the Rust programming language <a href="https://blog.rust-lang.org/2019/10/29/A-call-for-blogs-2020.html">call for blog posts</a> as input to the 2020 roadmap</p>
<p><em>Caveat: I am new to Rust. There&#8217;s probably stuff I don&#8217;t even know about that is more important than anything here. This is just me doing my part to give back to the awesome Rust community.</em></p>
]]></content:encoded>
					
					<wfw:commentRss>/2019/12/rust-2020/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
		<item>
		<title>nut loaf with red pepper sauce</title>
		<link>/2019/11/nut-loaf-with-red-pepper-sauce/</link>
					<comments>/2019/11/nut-loaf-with-red-pepper-sauce/#respond</comments>
		
		<dc:creator><![CDATA[sarah]]></dc:creator>
		<pubDate>Sat, 30 Nov 2019 02:27:36 +0000</pubDate>
				<category><![CDATA[general]]></category>
		<guid isPermaLink="false">/?p=6887</guid>

					<description><![CDATA[Slightly modified vegan nut loaf to avoid tomatoes. Nut loaf recipe can be also be used to make burger patties, pan fried or baked, or can be stuffed into puff pastry for a puff pastry loaf or small hand pies. Requires food processor to grind up various ingredients. Ingredients Nut loaf 1 1/4 cups (180&#8230; <a href="/2019/11/nut-loaf-with-red-pepper-sauce/">Continue reading <span class="meta-nav">&#8594;</span></a>]]></description>
										<content:encoded><![CDATA[<p>Slightly modified <a href="https://www.veganricha.com/2018/12/vegan-meatloaf-nut-loaf.html">vegan nut loaf</a> to avoid tomatoes.  Nut loaf recipe can be also be used to make burger patties, pan fried or baked, or can be stuffed into puff pastry for a puff pastry loaf or small hand pies.</p>
<p>Requires food processor to grind up various ingredients.</p>
<h2>Ingredients</h2>
<h3>Nut loaf</h3>
<p>1 1/4 cups (180 g) nuts (raw or roasted cashews, raw walnuts, raw pecans)<br />
1/4 cup (33.5 g) sunflower seeds (or more cashews)<br />
2 tsp oil (or 1/4 cup broth)<br />
1 cup (160 g) chopped onion<br />
4 cloves of garlic chopped<br />
1 cup (96 g) chopped mushrooms (shitake or hen of the wood)<br />
1 cup (140 g) cubed butternut squash<br />
1 tsp each thyme, sage, rosemary, oregano<br />
1 tsp smoked paprika<br />
1/2 tsp black pepper<br />
1/4 tsp each cinnamon and nutmeg<br />
1/2 to 3/4 tsp salt<br />
2 tbsp soy sauce or tamari<br />
2 eggs (or 2 flax eggs for vegan)<br />
2/3 cup  (81 g) breadcrumbs</p>
<h3>Sauce</h3>
<p>1/4 cup roasted red peppers<br />
1.5 tbsp soy sauce/tamari (or use 1/4 tsp salt + 1 tbsp broth for soyfree)<br />
2 tbsp maple syrup<br />
2 tsp apple cider vinegar<br />
1/2 tsp (0.5 tsp) garlic powder</p>
<h2>Instructions</h2>
<p>Preheat the oven to 350 degrees F.</p>
<ol>
<li>Toast the raw nuts and sunflower seeds in the oven at 325 deg F (160 C) for 5 mins.   </li>
<li>Food processor: pulse nuts and seeds to a somewhat coarse meal</li>
<li>In skillet over medium heat for 2 mins
<ul>
<li>oil or broth. </li>
<li>onion, garlic and a pinch of salt </li>
</ul>
</li>
<li>Add mushrooms and a pinch of salt and cook until some golden edges. (3-4 mins)</li>
<li>Add butternut squash and mix in. Add a splash of water, cover and cook until the squash is tender. </li>
<li>Mash and transfer to a bowl. </li>
<li>Add in the spices, salt and mix in. </li>
<li>Add the chopped nuts and seeds, soy sauce, eggs, breadcrumbs and mix well. </li>
<li>Taste and adjust salt, herbs and flavor. ** The flavor will get more pronounced on baking. If the mixture is too wet, add a tbsp or so flour. You want  it to be just slightly sticky. If too dry or crumbly, add a splash of broth. If you like sweeter, profile, add a tbsp of tomato paste or some chopped dried fruit such as dried cranberries or apricots. </li>
<li>Transfer to a parchment lined pan.  (I used lightly oiled cookie sheet.) Lightly press to shape. Do not pack too much. </li>
<li>Bake for 25 to 30 mins.</li>
</ol>
<p>Sauce:<br />
1. Blend roasted red peppers into a smooth paste<br />
2. Mix the rest of ingredients in a sauce pan over low heat for 15-20 minutes.<br />
3. Taste and adjust as needed.</p>
<p>Take the loaf out of the oven. Spread the glaze over the loaf and then bake again for 20 to 30 mins. Let cool for 15 mins before removing from the pan. Then cool completely before slicing. Serve with gravy or cranberry sauce or both!</p>
]]></content:encoded>
					
					<wfw:commentRss>/2019/11/nut-loaf-with-red-pepper-sauce/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
			</item>
	</channel>
</rss>
