{"id":6984,"date":"2020-01-05T18:39:54","date_gmt":"2020-01-06T02:39:54","guid":{"rendered":"https:\/\/www.ultrasaurus.com\/?p=6984"},"modified":"2020-01-05T18:39:54","modified_gmt":"2020-01-06T02:39:54","slug":"rust-on-heroku-with-hyper-http","status":"publish","type":"post","link":"https:\/\/www.ultrasaurus.com\/2020\/01\/rust-on-heroku-with-hyper-http\/","title":{"rendered":"rust on heroku with hyper http"},"content":{"rendered":"<p>Running an app on heroku requires at least one entry point responding to http.  An easy way to do this is to use <a href=\"hyper.rs\">hyper<\/a> to create a simple web service.<\/p>\n<h2>Setup<\/h2>\n<pre><code>cargo new hello_rust --bin\ncd hello_rust\ngit init\ngit add .\ngit commit -m \"cargo new hello_rust --bin\"\n<\/code><\/pre>\n<p>add to <code>Cargo.toml<\/code>:<\/p>\n<pre><code>[dependencies]\nhyper = \"0.13\"\n<\/code><\/pre>\n<h2>Web service code<\/h2>\n<p>The core code to set up a little web service has a few key parts:<\/p>\n<ol>\n<li>the service (<code>async fn hello<\/code>)\n<ul>\n<li>an async function that takes a <code>hyper::Request<\/code> and returns a <code>hyper::Response<\/code> in the <code>Result<\/code><\/li>\n<li><a href=\"https:\/\/docs.rs\/hyper\/0.13.1\/hyper\/struct.Request.html\">Request<\/a> is generic over the Body, so it seems nifty to be able to provide our own Rust types for specific content (like JSON) and also for validating API POST params <\/li>\n<li>Result is <a href=\"https:\/\/doc.rust-lang.org\/std\/convert\/enum.Infallible.html\">Infallible<\/a>: a Rust error type signifying that the function never returns an error<\/li>\n<\/ul>\n<\/li>\n<li><a href=\"https:\/\/docs.rs\/hyper\/0.13.1\/hyper\/service\/fn.make_service_fn.html\">make_service_fn<\/a> &#8212; docs are a bit sparse on this, but I think all it does it generate an instance of the service with the Request context that so that each request can run concurrently<\/li>\n<li>Server::bind(&amp;addr).serve(&#8230;) &#8212; Hyper uses a builder pattern where Server::bind generates a <a href=\"https:\/\/docs.rs\/hyper\/0.13.1\/hyper\/server\/struct.Builder.html\">Builder<\/a>, where you can configure http1\/2 support and then a running instance of the Server is created by calling the <a href=\"https:\/\/docs.rs\/hyper\/0.13.1\/hyper\/server\/struct.Builder.html#method.serve\">serve method<\/a> with the service function.   <\/li>\n<\/ol>\n<p>To see this in action, replace <code>main.rs<\/code> with this code:<\/p>\n<pre><code>use hyper::service::{make_service_fn, service_fn};\nuse hyper::{Body, Request, Response, Server};\nuse std::convert::Infallible;\n\nasync fn hello(_req: Request&lt;Body&gt;) -&gt; Result&lt;Response&lt;Body&gt;, Infallible&gt; {\n    Ok(Response::new(Body::from(\n        \"&lt;HTML&gt;&lt;H1&gt;Hello World!&lt;\/H1&gt;&lt;HTML&gt;\",\n    )))\n}\n\n#[tokio::main]\npub async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error + Send + Sync&gt;&gt; {\n\n    let make_svc = make_service_fn(|_conn| {\n        async { Ok::&lt;_, Infallible&gt;(service_fn(hello)) }\n    });\n\n    let addr = ([0, 0, 0, 0], 3000).into();\n\n    let server = Server::bind(&amp;addr).serve(make_svc);\n\n    println!(\"Listening on {}\", addr);\n\n    server.await?;\n\n    Ok(())\n}\n<\/code><\/pre>\n<p>to run the app locally:<\/p>\n<pre><code>cargo run\n<\/code><\/pre>\n<p>then in the browser, go to <a href=\"http:\/\/localhost:3000\/\">http:\/\/localhost:3000\/<\/a><\/p>\n<h2>Heroku setup<\/h2>\n<h3>1. Heroku CLI<\/h3>\n<p>Install <a href=\"https:\/\/devcenter.heroku.com\/articles\/heroku-cli\">heroku CLI<\/a> or if you already have it:<\/p>\n<p><code>heroku update<\/code><\/p>\n<p>Then to set up the app on heroku:<\/p>\n<pre><code>heroku create --buildpack emk\/rust\n<\/code><\/pre>\n<h3>2. Procfile<\/h3>\n<p>Add a Procfile for heroku to know what to call when it receives a web request:<\/p>\n<pre><code>echo \"web: .\/target\/release\/hello_rust\" &gt;&gt; Procfile\n<\/code><\/pre>\n<h3>3. Port configuration<\/h3>\n<p>Heroku requires that we listen on the port specified with the <code>PORT<\/code> env var.  So, add the following code and replace the hard-coded port number with this variable:<\/p>\n<pre><code>    let port = env::var(\"PORT\")\n        .unwrap_or_else(|_| \"3000\".to_string())\n        .parse()\n        .expect(\"PORT must be a number\");\n<\/code><\/pre>\n<h3>4. Deploy!<\/h3>\n<p>Deploy the app by pushing code to the Heroku remote repository that was set up by the CLI in step 1.<\/p>\n<pre><code> git push heroku master\n<\/code><\/pre>\n<p>Full code for the app is on <a href=\"https:\/\/github.com\/ultrasaurus\/hello-heroku-rust\/tree\/hyper\">github.com\/ultrasaurus\/hello-heroku-rust<\/a><\/p>\n<h2>Background<\/h2>\n<p>My environment info (<code>rustup show<\/code>):<\/p>\n<pre><code>stable-x86_64-apple-darwin (default)\nrustc 1.39.0 (4560ea788 2019-11-04)\n<\/code><\/pre>\n","protected":false},"excerpt":{"rendered":"<p>Running an app on heroku requires at least one entry point responding to http. An easy way to do this is to use hyper to create a simple web service. Setup cargo new hello_rust &#8211;bin cd hello_rust git init git add . git commit -m &#8220;cargo new hello_rust &#8211;bin&#8221; add to Cargo.toml: [dependencies] hyper =&hellip; <a href=\"https:\/\/www.ultrasaurus.com\/2020\/01\/rust-on-heroku-with-hyper-http\/\">Continue reading <span class=\"meta-nav\">&rarr;<\/span><\/a><\/p>\n","protected":false},"author":84,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[2],"tags":[],"_links":{"self":[{"href":"https:\/\/www.ultrasaurus.com\/wp-json\/wp\/v2\/posts\/6984"}],"collection":[{"href":"https:\/\/www.ultrasaurus.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.ultrasaurus.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.ultrasaurus.com\/wp-json\/wp\/v2\/users\/84"}],"replies":[{"embeddable":true,"href":"https:\/\/www.ultrasaurus.com\/wp-json\/wp\/v2\/comments?post=6984"}],"version-history":[{"count":8,"href":"https:\/\/www.ultrasaurus.com\/wp-json\/wp\/v2\/posts\/6984\/revisions"}],"predecessor-version":[{"id":6992,"href":"https:\/\/www.ultrasaurus.com\/wp-json\/wp\/v2\/posts\/6984\/revisions\/6992"}],"wp:attachment":[{"href":"https:\/\/www.ultrasaurus.com\/wp-json\/wp\/v2\/media?parent=6984"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.ultrasaurus.com\/wp-json\/wp\/v2\/categories?post=6984"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.ultrasaurus.com\/wp-json\/wp\/v2\/tags?post=6984"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}