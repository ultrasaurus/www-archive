{"id":6001,"date":"2016-07-02T11:52:08","date_gmt":"2016-07-02T18:52:08","guid":{"rendered":"https:\/\/www.ultrasaurus.com\/?p=6001"},"modified":"2016-07-02T12:05:52","modified_gmt":"2016-07-02T19:05:52","slug":"go-language-philosphy-thorugh-proverbs","status":"publish","type":"post","link":"https:\/\/www.ultrasaurus.com\/2016\/07\/go-language-philosphy-thorugh-proverbs\/","title":{"rendered":"go language philosphy thorugh proverbs"},"content":{"rendered":"<p>Rob Pike&#8217;s <a href=\"https:\/\/www.youtube.com\/watch?v=PAAkCSZUG1c&amp;feature=youtu.be\">Go Proverbs<\/a> convey many elements of the Go programming language philosphy in a way that is approachable and fun.  He compares with the game of Go, which is &#8220;easy to learn, and hard to master.&#8221;  Inspired by the &#8220;Go Proverbs Illustrated&#8221; book about patterns in playing the game of Go, he crafted a set of proverbs about the Go programming language.  His goal is that proverbs should be \u201cshort, poetic, general, about more than the Go programming language.  Contradictory is OK.  Life and programming are full of contradictions.\u201d These are ideas to explain to beginners or maybe in a code review.  He notes that there are probably many more.  These proverbs seek to capture the ideas that make programming in Go different.<\/p>\n<p><a href=\"https:\/\/thenounproject.com\/term\/skill-share\/14291\/\" rel=\"attachment wp-att-6005\"><img loading=\"lazy\" src=\"https:\/\/www.ultrasaurus.com\/wp-content\/uploads\/2016\/07\/noun_skill_share_14291-150x150.png\" alt=\"\" width=\"150\" height=\"150\" class=\"alignright size-thumbnail wp-image-6005\" srcset=\"https:\/\/www.ultrasaurus.com\/wp-content\/uploads\/2016\/07\/noun_skill_share_14291-150x150.png 150w, https:\/\/www.ultrasaurus.com\/wp-content\/uploads\/2016\/07\/noun_skill_share_14291-300x300.png 300w, https:\/\/www.ultrasaurus.com\/wp-content\/uploads\/2016\/07\/noun_skill_share_14291-768x768.png 768w, https:\/\/www.ultrasaurus.com\/wp-content\/uploads\/2016\/07\/noun_skill_share_14291-1024x1024.png 1024w, https:\/\/www.ultrasaurus.com\/wp-content\/uploads\/2016\/07\/noun_skill_share_14291.png 1200w\" sizes=\"(max-width: 150px) 100vw, 150px\" \/><\/a>The proverbs with my notes from the talk are listed below. I also found a lovely post with <a href=\"http:\/\/www.gregosuri.com\/2015\/12\/04\/go-proverbs-illustrated\/\">code illustrations<\/a> by <a href=\"https:\/\/twitter.com\/GregOsuri\">Greg Osuri<\/a>, as well as <a href=\"https:\/\/github.com\/ajstarks\/go-proverbs\">graphically illustrated deck<\/a> with nice icons chosen from the <a href=\"https:\/\/thenounproject.com\/\">noun project<\/a> and if you have additional proverbs to suggest, there&#8217;s now a <a href=\"https:\/\/go-proverbs.github.io\/\">github repo<\/a>.<\/p>\n<p><strong>\u201cDon\u2019t communicate by sharing memory, share memory by communicating\u201d<\/strong><br \/>\nPassing on a channel enables safe concurrent, even parallel operations.<\/p>\n<p><strong>\u201cConcurrency is not parallelism.\u201d<\/strong><br \/>\nThese are often confused by beginners.  How these are thought of in the Go community is that they are important to keep separate.  Concurrency is a way that you structure your program to make it easier to understand and scalable, and parallelism is simply the execution of multiple Go routines in parallel \u2014 somewhat a less interesting topic than concurrency.<\/p>\n<p><strong>\u201cChannels orchestrate; mutexes serialize\u201d<\/strong><br \/>\nMutexes are fine-grained and very small, and they tend to serialize execution.  If you put a mutex on a variable, then only one thing can ever happen to that variable at any one time (and that is often very important, and sometimes exactly what you want).  In the big picture of your program, channels give you a way to structure your program and arrange how the pieces work. As an example, how the \u201cSelect for loop\u201d uses channels to orchestrate your program.<\/p>\n<p><strong>\u201cThe bigger the interface, the weaker the abstraction\u201d<\/strong><br \/>\nIn Java, you think about interfaces having lots of methods.  In Go, we have interfaces which are not declared to be satisfied, they are satisfied implicitly, but even more important is the culture around interfaces that is captured by this proverb.  The smaller the interface is the more useful it is.  This is a Go-specific idea, we want to make little interfaces, so that we can build components that share them.<\/p>\n<p><strong>\u201cMake the zero value useful\u201d<\/strong><br \/>\nYou want to make it so that you can use a type without initializing it (if you can).<br \/>\nFor example: Bytes buffer or sync mutex &#8212; you don\u2019t have to call an init function, you don\u2019t have to call any methods.  There is nothing wrong with calling a constructor, sometimes you need that; however, if you can avoid it to make the program nicer, it just means there\u2019s less API there which is always a good thing.<\/p>\n<p><strong>\u201cinterface{} says nothing.\u201d<\/strong><br \/>\nWhen you are programming and have an empty interface, think very hard about whether that is really what you want&#8230;or whether there is just a little something that is really necessary to capture what you need.  Sometimes you do need an empty interface, but it is rare.  It is overused, especially by beginners.  You see this in almost any question on stackoverflow in Go.<\/p>\n<p><strong>\u201cGofmt&#8217;s style is no one&#8217;s favorite, yet gofmt is everyone&#8217;s favorite.\u201d<\/strong><br \/>\nExperienced Go Programmers will say \u201cI don\u2019t like how it formats, but I really like that it formats.\u201d<br \/>\n\u201cA little copying is better than a little dependency.\u201d<br \/>\nYou can make your programs compile faster and be simpler if you keep the dependency tree really, really small.  Sometimes you don\u2019t need that whole library, you just need those three lines of code, that you can just copy and it\u2019s fine.<\/p>\n<p><strong>\u201cSyscall must always be guarded with build tags.\u201d<\/strong><br \/>\nSyscall isn\u2019t portable &#8212; that is the point.  If you import it, you must have a build tag for the architecture and operating system that syscall invocation is valid for.  If you think you have a portable thing you are using the wrong package.  Check out \u2018os\u2019 or something else.<\/p>\n<p><strong>\u201cCgo must always be guarded with build tags.\u201d<\/strong><br \/>\nSame as above.  If you are calling C, god knows what it does!  It\u2019s very non-portable.  It needs to be built for specific architectures and operating systems.<\/p>\n<p><strong>\u201cCgo is not Go.\u201d<\/strong><br \/>\nA lot of people in the early days would write about how a favorite feature of Go was how easily it connected to C, but lots of times it shouldn\u2019t be necessary, it takes you out of the Go universe and you lose the benefits of Go if you are coding in C.<\/p>\n<p><strong>\u201cWith the unsafe package there are no guarantees.\u201d<\/strong><br \/>\nA lot of people use \u201cunsafe\u201d and then complain that things don\u2019t work\u2026 that\u2019s the point, don\u2019t use \u201cunsafe\u201d unless you are prepared to have your program break one day.<\/p>\n<p><strong>\u201cClear is better than clever.\u201d<\/strong><br \/>\nAmen.  There are languages that celebrate cleverness.  Go celebrates simple clear code.  The Go philosophy values code readability.<\/p>\n<p><strong>\u201cReflection is never clear.\u201d<\/strong><br \/>\nCommon Stackoverflow question of people wanting to use reflect and complaining that it doesn\u2019t work.  It doesn\u2019t work, because it is not for you.  Very, very few people should be playing with this.  Powerful, yet very difficult to use.  We should encourage beginners to step away from using reflection and use the language proper.<\/p>\n<p><strong>\u201cErrors are values.\u201d<\/strong><br \/>\nBeginners struggle with this. Too often people write \u201cerr != nil\u201d &#8212; they think about substituting try\/catch.  Errors are just values&#8230;<\/p>\n<p><strong>\u201cDon&#8217;t just check errors, handle them gracefully.\u201d<\/strong><br \/>\nThink about whether you should be doing something with errors.  People are too quick to just return an error up the tree, instead of designing how it should work.  A big part of writing good Go code is getting the error handling right up front.  Of any program really, but its easier to program with errors as just values, and easier to do it gracefully.<\/p>\n<p><strong>\u201cDesign the architecture, name the components, document the details.\u201d<\/strong><br \/>\nThink of really good names for the pieces.  If the names are good, the code will be easy to understand and the design will be clear inside your pogram, and programming your system will feel natural.  Names should express your design.<\/p>\n<p><strong>\u201cDocumentation is for users.\u201d<\/strong><br \/>\nThink about what the function is for, not what it does. You want to write something that the programmer using your function will find helpful.<\/p>\n","protected":false},"excerpt":{"rendered":"<p>Rob Pike&#8217;s Go Proverbs convey many elements of the Go programming language philosphy in a way that is approachable and fun. He compares with the game of Go, which is &#8220;easy to learn, and hard to master.&#8221; Inspired by the &#8220;Go Proverbs Illustrated&#8221; book about patterns in playing the game of Go, he crafted a&hellip; <a href=\"https:\/\/www.ultrasaurus.com\/2016\/07\/go-language-philosphy-thorugh-proverbs\/\">Continue reading <span class=\"meta-nav\">&rarr;<\/span><\/a><\/p>\n","protected":false},"author":84,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.ultrasaurus.com\/wp-json\/wp\/v2\/posts\/6001"}],"collection":[{"href":"https:\/\/www.ultrasaurus.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.ultrasaurus.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.ultrasaurus.com\/wp-json\/wp\/v2\/users\/84"}],"replies":[{"embeddable":true,"href":"https:\/\/www.ultrasaurus.com\/wp-json\/wp\/v2\/comments?post=6001"}],"version-history":[{"count":0,"href":"https:\/\/www.ultrasaurus.com\/wp-json\/wp\/v2\/posts\/6001\/revisions"}],"wp:attachment":[{"href":"https:\/\/www.ultrasaurus.com\/wp-json\/wp\/v2\/media?parent=6001"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.ultrasaurus.com\/wp-json\/wp\/v2\/categories?post=6001"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.ultrasaurus.com\/wp-json\/wp\/v2\/tags?post=6001"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}