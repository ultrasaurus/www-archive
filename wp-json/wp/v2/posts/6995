{"id":6995,"date":"2020-01-15T22:36:12","date_gmt":"2020-01-16T06:36:12","guid":{"rendered":"https:\/\/www.ultrasaurus.com\/?p=6995"},"modified":"2020-02-10T06:00:16","modified_gmt":"2020-02-10T14:00:16","slug":"writing-c-library-in-rust","status":"publish","type":"post","link":"https:\/\/www.ultrasaurus.com\/2020\/01\/writing-c-library-in-rust\/","title":{"rendered":"writing c library in rust"},"content":{"rendered":"<p>I want to write a library in Rust that can be called from C and just as easily called from Rust code.  The tooling makes it pretty easy, but I had to look in a few places to figure how it is supposed to work and get tests running in both languages.<\/p>\n<h1>C library<\/h1>\n<p>To focus on the process of building and testing, the library will have a single function that adds two numbers.  I wrote it in pure C first:<\/p>\n<p>lib.c<\/p>\n<pre><code>int add(int a, int b) {\n  return a + b;\n}\n<\/code><\/pre>\n<p>lib.h<\/p>\n<pre><code>int add(int a, int b);\n<\/code><\/pre>\n<p>main.c<\/p>\n<pre><code>#include &lt;stdio.h&gt;\n#include \"lib.h\"\n\nint main() {\n    int sum = add(1,2);\n    printf(\"1 + 2 = %d\\n\", sum);\n}\n<\/code><\/pre>\n<p>one-liner to compile and run the app<\/p>\n<pre><code>gcc *.c -o app &amp;&amp; .\/app\n<\/code><\/pre>\n<p>output: <code>1 + 2 = 3<\/code><\/p>\n<p>then I wrote a simple automated test, based on <a href=\"https:\/\/eradman.com\/posts\/tdd-in-c.html\">tdd blog post<\/a><\/p>\n<h1>Rust library<\/h1>\n<pre><code>cargo new add --lib\n<\/code><\/pre>\n<p>replace lib.rs with<\/p>\n<pre><code>#[no_mangle]\npub extern \"C\" fn add(a: i32, b:i32) -&gt; i32 {\n    a + b\n}\n\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn it_works() {\n        use crate::add;\n        assert_eq!(add(2,2), 4);\n    }\n}\n<\/code><\/pre>\n<p>build and run with <code>cargo test<\/code><br \/>\nwhich should have output like<\/p>\n<pre><code>$ cargo test\n    Finished dev [unoptimized + debuginfo] target(s) in 0.01s\n     Running target\/debug\/deps\/add-45abb08ccefdc53c\n\nrunning 1 test\ntest tests::it_works ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n\n   Doc-tests add\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\n<\/code><\/pre>\n<h2>Compile as static library<\/h2>\n<p>Add to <code>Cargo.toml<\/code><\/p>\n<pre><code>[lib]\nname = \"add\"\ncrate-type = [\"staticlib\"]  \n<\/code><\/pre>\n<p>Now <code>cargo build<\/code> generates a compiled library file: <code>target\/debug\/libadd.a<\/code>.  I could have stopped there, but I expect to iterate on this a bit and I had read about a crate that generates the C header file&#8230;<\/p>\n<h2>Generate a header (command-line)<\/h2>\n<p>First, install the lovely <a href=\"https:\/\/github.com\/eqrion\/cbindgen\">cbindgen<\/a> crate (using &#8211;force just to make sure everything is up to date with the latest):<\/p>\n<pre><code>cargo install --force cbindgen\n<\/code><\/pre>\n<p>the command-line tool is pretty neat:<\/p>\n<pre><code>touch cbindgen.toml    # can be empty for defaults\ncbindgen --config cbindgen.toml --crate add --output add.h\n<\/code><\/pre>\n<p>The above command will generate &#8220;add.h&#8221; file at the root of the crate.<\/p>\n<h2>Generate a header (cargo build)<\/h2>\n<p>I prefer to have the header generation integrated with cargo build (or at least I think I will).  Here are the steps:<\/p>\n<p>Add to <code>Cargo.toml<\/code>:<\/p>\n<pre><code>[build-dependencies]\ncbindgen = \"0.12\"\n<\/code><\/pre>\n<p>By default, the header file is buried in <code>target\/debug\/build\/add-...<\/code> with a bunch of intermediary build files.  I find that it is nice to put it at the root of my crate where it is easy to find. Below is a custom build file that puts it in the crate root (aka <code>CARGO_MANIFEST_DIR<\/code>, the directory that <code>Cargo.toml<\/code> is in).<\/p>\n<p>build.rs:<\/p>\n<pre><code>extern crate cbindgen;\n\nuse std::env;\nuse std::path::PathBuf;\n\n\nfn main() {\n  let crate_dir = PathBuf::from(env::var(\"CARGO_MANIFEST_DIR\")\n        .expect(\"CARGO_MANIFEST_DIR env var is not defined\"));\n\n  let config = cbindgen::Config::from_file(\"cbindgen.toml\")\n        .expect(\"Unable to find cbindgen.toml configuration file\");\n\n  cbindgen::generate_with_config(&amp;crate_dir, config)\n        .expect(\"Unable to generate bindings\")\n        .write_to_file(crate_dir.join(\"add.h\"));\n}\n<\/code><\/pre>\n<p>As mentioned above, <code>cbindgen.toml<\/code> may be empty, but here&#8217;s some settings I like:<\/p>\n<pre><code>include_guard = \"add_h\"\nautogen_warning = \"\/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. *\/\"\nlanguage = \"C\"\nincludes = []\nsys_includes = [\"stdint.h\"]\nno_includes = true   \n<\/code><\/pre>\n<p>Confusingly <code>no_includes<\/code> means no <em>extra<\/em> includes.  I prefer to have only the ones that I know are needed, rather than some random list of &#8220;common&#8221; headers.<\/p>\n<p>Here&#8217;s my generated header:<\/p>\n<pre><code>#ifndef add_h\n#define add_h\n\n\/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. *\/\n\n#include &lt;stdint.h&gt;\n\nint32_t add(int32_t a, int32_t b);\n\n#endif \/* add_h *\/\n<\/code><\/pre>\n<h2>Putting it all together<\/h2>\n<p>Example <code>main.c<\/code> in the root of the crate:<\/p>\n<pre><code>#include &lt;stdio.h&gt;\n#include \"add.h\"\n\nint main() {\n    int sum = add(1,2);\n    printf(\"1 + 2 = %d\\n\", sum);\n}\n<\/code><\/pre>\n<p>compile and run:<\/p>\n<pre><code>gcc main.c add\/target\/debug\/libadd.a -o app &amp;&amp; .\/app\n<\/code><\/pre>\n<p>outputs: <code>1 + 2 = 3<\/code><\/p>\n<p>This make me unreasonably happy.  Rust syntax can be a bit finicky and certainly takes a bit of getting used, but this kind of tooling could more than make up for that in accelerating the dev cycle.<\/p>\n<p>For the full applications with a mini test suite in C, see <a href=\"https:\/\/github.com\/ultrasaurus\/rust-clib\/tree\/v0.1\">github\/ultrasaurus\/rust-clib<\/a> &#8212; the v0.1 branch is from when this blog post was written.<\/p>\n","protected":false},"excerpt":{"rendered":"<p>I want to write a library in Rust that can be called from C and just as easily called from Rust code. The tooling makes it pretty easy, but I had to look in a few places to figure how it is supposed to work and get tests running in both languages. C library To&hellip; <a href=\"https:\/\/www.ultrasaurus.com\/2020\/01\/writing-c-library-in-rust\/\">Continue reading <span class=\"meta-nav\">&rarr;<\/span><\/a><\/p>\n","protected":false},"author":84,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[2],"tags":[],"_links":{"self":[{"href":"https:\/\/www.ultrasaurus.com\/wp-json\/wp\/v2\/posts\/6995"}],"collection":[{"href":"https:\/\/www.ultrasaurus.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.ultrasaurus.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.ultrasaurus.com\/wp-json\/wp\/v2\/users\/84"}],"replies":[{"embeddable":true,"href":"https:\/\/www.ultrasaurus.com\/wp-json\/wp\/v2\/comments?post=6995"}],"version-history":[{"count":8,"href":"https:\/\/www.ultrasaurus.com\/wp-json\/wp\/v2\/posts\/6995\/revisions"}],"predecessor-version":[{"id":7014,"href":"https:\/\/www.ultrasaurus.com\/wp-json\/wp\/v2\/posts\/6995\/revisions\/7014"}],"wp:attachment":[{"href":"https:\/\/www.ultrasaurus.com\/wp-json\/wp\/v2\/media?parent=6995"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.ultrasaurus.com\/wp-json\/wp\/v2\/categories?post=6995"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.ultrasaurus.com\/wp-json\/wp\/v2\/tags?post=6995"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}