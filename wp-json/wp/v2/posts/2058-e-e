{"id":2058,"date":"2009-09-13T10:13:57","date_gmt":"2009-09-13T18:13:57","guid":{"rendered":"https:\/\/www.ultrasaurus.com\/?p=2058"},"modified":"2009-09-13T10:13:57","modified_gmt":"2009-09-13T18:13:57","slug":"rails-exceptions-in-xml","status":"publish","type":"post","link":"https:\/\/www.ultrasaurus.com\/2009\/09\/rails-exceptions-in-xml\/","title":{"rendered":"rails exceptions in xml"},"content":{"rendered":"<p>We ran into an issue last week where our XML APIs were returning HTML under certain error conditions, rather than the expected XML.  Our solution was to add the following code to the ApplicationController:<\/p>\n<pre>\n  rescue_from Exception do |exception|\n    respond_to do |format|\n      format.xml  { render :xml =&gt; \n           \"&lt;error&gt;Internal Server Error #{exception.message}&lt;\/error&gt;\", \n           :status =&gt; 500 }\n      format.html { render :html =&gt; {:file =&gt; 'public\/500.html'}, :status =&gt; 500 }\n      format.json { render :json =&gt; \n            {:error =&gt; \"Internal Server Error #{exception.message}\"}.to_json, \n             :status =&gt; 500 }\n    end\n  end\n<\/pre>\n<p>We might have also declared a rescue_action, and I&#8217;m not sure of the benefits of one over the other, except that perhaps we needed to implement a general form of rescue_from since we had another more specific form already declared.<\/p>\n<p>It seemed to me that this should be the default behavior in rails, so I decided to dig into it a little more and see what I could discover.  I started by making a little test app to reproduce the exception.  The particular case from last week was a database limit that wasn&#8217;t being caught in the app with a length validation.  When I tried to re-create the error in MySql, I noticed that no exception is thrown since MySql will just truncate the data (although perhaps that is only because I am not running MySql in strict mode).  In PostgreSQL, the database layer will throw an exception.<\/p>\n<p>Test app setup:<\/p>\n<pre>\nrails -d postgresql test_postgresql\ncd test_postgresql\/\nscript\/generate scaffold person first:string last:string present:boolean\n<\/pre>\n<p>Edit the migration to create a database limit:<\/p>\n<pre>\nclass CreatePeople &lt; ActiveRecord::Migration\n  def self.up\n    create_table :people do |t|\n      t.string :first, :limit =&gt; 40\n      t.string :last, :limit =&gt; 40\n      t.boolean :present\n\n      t.timestamps\n    end\n  end\n\n  def self.down\n    drop_table :people\n  end\nend\n<\/pre>\n<p>Create the postgres user.  Note double-quotes around user, single quotes around password. It has to be that way.  Go figure.<\/p>\n<pre>\n$ sudo su postgres -c psql\npostgres=# create user \"test_postgresql\" with superuser password 'password';\nCREATE ROLE\npostgres=# q\n<\/pre>\n<p>Finally create the database, run migration, and start the server:<\/p>\n<pre> \nrake db:create:all\nrake db:migrate\n.\/script\/server\n<\/pre>\n<p>If you point your browser at http:\/\/localhost:3000\/people and try to create a person with more that 40 characters in the first name, you will see the following error:<\/p>\n<pre>\nActiveRecord::StatementInvalid in PeopleController#create\nPGError: ERROR:  value too long for type character varying(40)\n<\/pre>\n<p>That is all well and good; however, if you do the same in XML, you will get the same error in <strong>HTML<\/strong>.<\/p>\n<pre width=\"80\">\n$ curl -X POST -d &quot;&lt;person&gt;&lt;first&gt;This is a first name that is too long for the database limit&lt;\/first&gt;&lt;\/person&gt;&quot; -H &quot;Content-Type: application\/xml&quot; http:\/\/localhost:3000\/people.xml\n&lt;html xmlns=&quot;http:\/\/www.w3.org\/1999\/xhtml&quot;&gt;\n&lt;head&gt;\n  &lt;title&gt;Action Controller: Exception caught&lt;\/title&gt;\n  &lt;style&gt;\n    body { background-color: #fff; color: #333; }\n\n    body, p, ol, ul, td {\n      font-family: verdana, arial, helvetica, sans-serif;\n      font-size:   13px;\n      line-height: 18px;\n    }\n<\/pre>\n<p>That seems like a bug to me.  Perhaps this should be a lighthouse ticket rather than a blog post.. still not confident in identifying bugs in Rails, so I figured I&#8217;d post here first.<\/p>\n","protected":false},"excerpt":{"rendered":"<p>We ran into an issue last week where our XML APIs were returning HTML under certain error conditions, rather than the expected XML. Our solution was to add the following code to the ApplicationController: rescue_from Exception do |exception| respond_to do |format| format.xml { render :xml =&gt; &#8220;&lt;error&gt;Internal Server Error #{exception.message}&lt;\/error&gt;&#8221;, :status =&gt; 500 } format.html&hellip; <a href=\"https:\/\/www.ultrasaurus.com\/2009\/09\/rails-exceptions-in-xml\/\">Continue reading <span class=\"meta-nav\">&rarr;<\/span><\/a><\/p>\n","protected":false},"author":84,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[2],"tags":[],"_links":{"self":[{"href":"https:\/\/www.ultrasaurus.com\/wp-json\/wp\/v2\/posts\/2058"}],"collection":[{"href":"https:\/\/www.ultrasaurus.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.ultrasaurus.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.ultrasaurus.com\/wp-json\/wp\/v2\/users\/84"}],"replies":[{"embeddable":true,"href":"https:\/\/www.ultrasaurus.com\/wp-json\/wp\/v2\/comments?post=2058"}],"version-history":[{"count":0,"href":"https:\/\/www.ultrasaurus.com\/wp-json\/wp\/v2\/posts\/2058\/revisions"}],"wp:attachment":[{"href":"https:\/\/www.ultrasaurus.com\/wp-json\/wp\/v2\/media?parent=2058"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.ultrasaurus.com\/wp-json\/wp\/v2\/categories?post=2058"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.ultrasaurus.com\/wp-json\/wp\/v2\/tags?post=2058"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}