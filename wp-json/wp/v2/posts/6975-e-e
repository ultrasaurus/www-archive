{"id":6975,"date":"2020-01-04T20:27:25","date_gmt":"2020-01-05T04:27:25","guid":{"rendered":"https:\/\/www.ultrasaurus.com\/?p=6975"},"modified":"2020-01-05T20:24:51","modified_gmt":"2020-01-06T04:24:51","slug":"rust-on-heroku-with-async-await-and-tokio","status":"publish","type":"post","link":"https:\/\/www.ultrasaurus.com\/2020\/01\/rust-on-heroku-with-async-await-and-tokio\/","title":{"rendered":"rust on heroku with async\/await and tokio"},"content":{"rendered":"<p>In an effort to understand the new Rust async\/await syntax, I made a super-simple app that simply responds to all HTTP requests with <strong>Hello!<\/strong> and deployed on <a href=\"https:\/\/www.heroku.com\/\">Heroku<\/a>.<\/p>\n<p>Update: If you just want to create a webservice in Rust and deploy on Heroku, I recommend next blog post: <a href=\"https:\/\/www.ultrasaurus.com\/2020\/01\/rust-on-heroku-with-hyper-http\/\">rust on heroku with hyper http<\/a>. This blog post focuses on the details of how the underlying request and response is handled with async\/await, on <a href=\"https:\/\/blog.rust-lang.org\/2019\/11\/07\/Async-await-stable.html\">stable Rust since 11\/2019<\/a>.<\/p>\n<p>The full source code and README instructions can be found on <a href=\"https:\/\/github.com\/ultrasaurus\/hello-heroku-rust\/tree\/tokio-only\">github.com\/ultrasaurus\/hello-heroku-rust, tokio-only branch<\/a><\/p>\n<h2>Rust &#8220;hello world&#8221; app<\/h2>\n<p>Make a new project with cargo<\/p>\n<pre><code>cargo new hello_rust --bin\ncd hello_rust\ngit init\ngit add .\ngit commit -m \u201ccargo new hello_rust \u2014bin\u201d\n\ncargo run\n<\/code><\/pre>\n<p>output:<\/p>\n<pre><code>   Compiling hello_rust v0.1.0 (\/Users\/sallen\/src\/rust\/hello_rust)\n    Finished dev [unoptimized + debuginfo] target(s) in 1.47s\n     Running `target\/debug\/hello_rust`\nHello, world!\n<\/code><\/pre>\n<h2>Heroku setup<\/h2>\n<p>Rust isn&#8217;t officially supported by Heroku yet, but there are lots of &#8220;buildpacks&#8221; which help to deploy a Rust app.  I picked <a href=\"https:\/\/github.com\/emk\/heroku-buildpack-rust\">emk\/heroku-buildpack-rust<\/a> &#8212; most stars, most forks &amp; recently updated!<\/p>\n<p>We need the <a href=\"https:\/\/devcenter.heroku.com\/articles\/heroku-cli\">heroku CLI<\/a>. I already had it and just did <code>heroku update<\/code> to sync to latest version (<code>7.35.1<\/code>).  Then to set up the app on heroku:<\/p>\n<pre><code>heroku create --buildpack emk\/rust\n<\/code><\/pre>\n<p>output provides a unique hostname by default:<\/p>\n<pre><code>Creating app... done, \u2b22 peaceful-gorge-05620\nSetting buildpack to emk\/rust... done\nhttps:\/\/peaceful-gorge-05620.herokuapp.com\/ | https:\/\/git.heroku.com\/peaceful-gorge-05620.git\n<\/code><\/pre>\n<p>We need a Procfile so heroku knows our entrypoint<\/p>\n<pre><code>echo \"web: .\/target\/release\/hello_rust\" &gt;&gt; Procfile\n<\/code><\/pre>\n<h2>Write the app<\/h2>\n<p>Add crate dependencies to <code>Cargo.toml<\/code> and add code to <code>main.rs<\/code> (and other files as with any Rust app).  The <em>emk\/rust buildpack<\/em> takes care of building everything as part of the heroku deploy.<\/p>\n<p>The following lines (in <code>Cargo.toml<\/code>) will add all of tokio features:<\/p>\n<pre><code>[dependencies]\ntokio = { version = \"0.2\", features = [\"full\"] }\n<\/code><\/pre>\n<p>I&#8217;d rather specify only what&#8217;s needed, but ran into something I couldn&#8217;t debug myself (<a href=\"https:\/\/github.com\/tokio-rs\/tokio\/issues\/2050\">issue#2050<\/a>)<\/p>\n<p>The core of the app accepts the sockets connections, but doesn&#8217;t read\/write:<\/p>\n<pre><code>use std::env;\nuse tokio::net::TcpListener;\n\n#[tokio::main]\nasync fn main() {\n    \/\/ Get the port number to listen on (required for heroku deployment).\n    let port = env::var(\"PORT\").unwrap_or_else(|_| \"1234\".to_string());\n\n    let addr = format!(\"0.0.0.0:{}\", port);\n    let mut listener = TcpListener::bind(addr).await.unwrap();\n\n    loop {\n        println!(\"listening on port {}...\", port);\n        let result = listener.accept().await;\n        match result {\n            Err(e) =&gt; println!(\"listen.accept() failed, err: {:?}\", e),\n            Ok(listen) =&gt; {\n                let (socket, addr) = listen;\n                println!(\"socket connection accepted, {}\", addr);\n                println!(\"not doing anything yet\");\n            }\n        }\n    }\n}\n<\/code><\/pre>\n<h2>Deploy on heroku<\/h2>\n<p>The above code will build and deploy, by simply pushing the code to heroku:<\/p>\n<pre><code>heroku push origin master\n<\/code><\/pre>\n<p>We can see what it is doing with <code>heroku logs --tail<\/code>:<\/p>\n<p>Here&#8217;s where it starts the build and then kills the old app:<\/p>\n<pre><code>2020-01-05T03:45:31.000000+00:00 app[api]: Build started by user ...\n2020-01-05T03:45:50.450898+00:00 heroku[web.1]: Restarting\n2020-01-05T03:45:50.454311+00:00 heroku[web.1]: State changed from up to starting\n2020-01-05T03:45:50.244579+00:00 app[api]: Deploy 399e1c85 by user ...\n2020-01-05T03:45:50.244579+00:00 app[api]: Release v24 created by user ...\n2020-01-05T03:45:50.701533+00:00 heroku[web.1]: Starting process with command `.\/target\/release\/hello_rust`\n2020-01-05T03:45:51.741040+00:00 heroku[web.1]: Stopping all processes with SIGTERM\n2020-01-05T03:45:51.819864+00:00 heroku[web.1]: Process exited with status 143\n<\/code><\/pre>\n<p>Oddly, it seems to start the app before &#8220;State changed from starting to up&#8221; but it will fail if we&#8217;re not listening on the right port, so maybe that is as expected:<\/p>\n<pre><code>2020-01-05T03:45:52.343368+00:00 app[web.1]: listening on port 49517...\n2020-01-05T03:45:53.322238+00:00 heroku[web.1]: State changed from starting to up\n2020-01-05T03:45:53.303486+00:00 app[web.1]: socket connection accepted, 10.171.202.59:17201\n2020-01-05T03:45:53.303545+00:00 app[web.1]: not doing anything yet\n2020-01-05T03:45:53.303619+00:00 app[web.1]: listening on port 49517...\n2020-01-05T03:45:53.313259+00:00 app[web.1]: socket connection accepted, 172.17.146.217:43686\n2020-01-05T03:45:53.313285+00:00 app[web.1]: not doing anything yet\n2020-01-05T03:45:53.313370+00:00 app[web.1]: listening on port 49517...\n2020-01-05T03:46:28.000000+00:00 app[api]: Build succeeded\n2020-01-05T03:46:48.251168+00:00 heroku[router]: at=error code=H13 desc=\"Connection closed without response\" method=GET path=\"\/\" host=peaceful-gorge-05620.herokuapp.com request_id=a0d630d9-790a-47db-87af-67e680b27907 fwd=\"69.181.194.59\" dyno=web.1 connect=1ms service=1ms status=503 bytes=0 protocol=https\n<\/code><\/pre>\n<p>So, the first socket connection above is some internal heroku checker, then when I attempt to go to the app URL in the browser, it fails (as expected).<\/p>\n<h2>Async read and write<\/h2>\n<p>I tried to keep the code clear with as little <em>magic<\/em> as possible.  It&#8217;s a bit verbose (without even handling HTTP in any general way), but I found it helpful to see the details of read and write.<\/p>\n<p>Note that adding <code>use tokio::prelude::*;<\/code> allows calling of <code>read_line<\/code> (defined in <code>tokio::io::AsyncBufReadExt<\/code>) and <code>write_all<\/code> (defined in <code>tokio::io::AsyncWriteExt<\/code>).<br \/>\nThe additional code reads the bytes from the socket line by line until we get the the end of the HTTP Request (signalled by a blank line).  So we look for two CLRFs (one at the end of the last header line and one for the blank line).<\/p>\n<p><code>tokio::spawn(async move<\/code> makes it so sure we can read\/write from one socket while also listening for additional connections. <code>tokio::spawn<\/code> will allow the program execution to continue, while concurrently allowing our async function <code>process_socket<\/code> to read and write from the socket.  Because we added <code>#[tokio::main]<\/code> above our <code>async fn main<\/code> entry point, tokio will set up an executor which will wait for all of our spawned tasks to complete before exiting.<\/p>\n<pre><code>use std::env;\nuse tokio::net::TcpListener;\nuse tokio::prelude::*;\n\n#[tokio::main]\nasync fn main() {\n    \/\/ Get the port number to listen on (required for heroku deployment).\n    let port = env::var(\"PORT\").unwrap_or_else(|_| \"1234\".to_string());\n\n    let addr = format!(\"0.0.0.0:{}\", port);\n    let mut listener = TcpListener::bind(addr).await.unwrap();\n\n    loop {\n        println!(\"listening on port {}...\", port);\n        let result = listener.accept().await;\n        match result {\n            Err(e) =&gt; println!(\"listen.accept() failed, err: {:?}\", e),\n            Ok(listen) =&gt; {\n                let (socket, addr) = listen;\n                println!(\"socket connection accepted, {}\", addr);\n                \/\/ Process each socket concurrently.\n                tokio::spawn(async move {\n                    let mut buffed_socket = tokio::io::BufReader::new(socket);\n                    let mut request = String::new();\n                    let mut result;\n                    loop {\n                        result = buffed_socket.read_line(&amp;mut request).await;\n                        if let Ok(num_bytes) = result {\n                            if num_bytes &gt; 0 &amp;&amp; request.len() &gt;= 4 {\n                                let end_chars = &amp;request[request.len() - 4..];\n                                if end_chars == \"\\r\\n\\r\\n\" {\n                                    break;\n                                };\n                            }\n                        }\n                    }\n                    if let Err(e) = result {\n                        println!(\"failed to read from socket, err: {}\", e);\n                        return;\n                    }\n                    let html = \"&lt;h1&gt;Hello!&lt;\/h1&gt;\";\n                    println!(\"request: {}\", request);\n                    let response = format!(\n                        \"HTTP\/1.1 200\\r\\nContent-Length: {}\\r\\n\\r\\n{}\",\n                        html.len(),\n                        html\n                    );\n                    let write_result = buffed_socket.write_all(response.as_bytes()).await;\n                    if let Err(e) = write_result {\n                        println!(\"failed to write, err: {}\", e);\n                    }\n                });\n            }\n        }\n    }\n}\n<\/code><\/pre>\n<h2>Background<\/h2>\n<p>Here&#8217;s my environment info (<code>rustup show<\/code>):<\/p>\n<pre><code>stable-x86_64-apple-darwin (default)\nrustc 1.39.0 (4560ea788 2019-11-04)\n<\/code><\/pre>\n<p>Reference docs<\/p>\n<ul>\n<li>https:\/\/docs.rs\/tokio\/0.2.6\/tokio\/net\/struct.TcpListener.html<\/li>\n<li>https:\/\/docs.rs\/tokio\/0.2.6\/tokio\/net\/struct.TcpStream.html<\/li>\n<li>https:\/\/docs.rs\/tokio\/0.2.6\/tokio\/task\/fn.spawn.html<\/li>\n<\/ul>\n","protected":false},"excerpt":{"rendered":"<p>In an effort to understand the new Rust async\/await syntax, I made a super-simple app that simply responds to all HTTP requests with Hello! and deployed on Heroku. Update: If you just want to create a webservice in Rust and deploy on Heroku, I recommend next blog post: rust on heroku with hyper http. This&hellip; <a href=\"https:\/\/www.ultrasaurus.com\/2020\/01\/rust-on-heroku-with-async-await-and-tokio\/\">Continue reading <span class=\"meta-nav\">&rarr;<\/span><\/a><\/p>\n","protected":false},"author":84,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[2],"tags":[],"_links":{"self":[{"href":"https:\/\/www.ultrasaurus.com\/wp-json\/wp\/v2\/posts\/6975"}],"collection":[{"href":"https:\/\/www.ultrasaurus.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.ultrasaurus.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.ultrasaurus.com\/wp-json\/wp\/v2\/users\/84"}],"replies":[{"embeddable":true,"href":"https:\/\/www.ultrasaurus.com\/wp-json\/wp\/v2\/comments?post=6975"}],"version-history":[{"count":10,"href":"https:\/\/www.ultrasaurus.com\/wp-json\/wp\/v2\/posts\/6975\/revisions"}],"predecessor-version":[{"id":6994,"href":"https:\/\/www.ultrasaurus.com\/wp-json\/wp\/v2\/posts\/6975\/revisions\/6994"}],"wp:attachment":[{"href":"https:\/\/www.ultrasaurus.com\/wp-json\/wp\/v2\/media?parent=6975"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.ultrasaurus.com\/wp-json\/wp\/v2\/categories?post=6975"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.ultrasaurus.com\/wp-json\/wp\/v2\/tags?post=6975"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}