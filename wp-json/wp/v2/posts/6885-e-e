{"id":6885,"date":"2019-12-01T01:37:16","date_gmt":"2019-12-01T09:37:16","guid":{"rendered":"https:\/\/www.ultrasaurus.com\/?p=6885"},"modified":"2019-12-24T09:30:40","modified_gmt":"2019-12-24T17:30:40","slug":"rust-2020","status":"publish","type":"post","link":"https:\/\/www.ultrasaurus.com\/2019\/12\/rust-2020\/","title":{"rendered":"rust 2020: fulfill the promise"},"content":{"rendered":"<p>As a newcomer to Rust, my suggestion for 2020 theme is to fulfill the promise of &#8220;empowering everyone to build reliable and efficient software&#8221; by finishing what&#8217;s started (rather than adding new features), continuing the focus on good docs and good tools, and expanding to develop a coherent ecosystem.<\/p>\n<blockquote><p>\n  Rust empowers you to reach farther, to program with confidence in a wider variety of domains than you did before. &#8212; <a href=\"https:\/\/doc.rust-lang.org\/book\/foreword.html\">Rust Language Book forward<\/a>\n<\/p><\/blockquote>\n<h2>Overview themes<\/h2>\n<p>2020 roadmap: finish what&#8217;s started, fulfill the promise<\/p>\n<p>2021 edition: scalability &#8211; Can newcomers to Rust create a real-world, complex system without recreating basic components or contributing to the language itself?<\/p>\n<ul>\n<li>more scalable systems written in Rust<\/li>\n<li>experienced C\/C++ engineers can easily transition to Rust<\/li>\n<li>more scalable ecosystem\n<ul>\n<li>commonly needed libraries are available<\/li>\n<li>new engineers can easily become contributors<\/li>\n<\/ul>\n<\/li>\n<\/ul>\n<h2>Keep doing<\/h2>\n<ul>\n<li>Tooling is great! rustup toolchain, feature flags, online\/offline docs make it easy to experiment with new Rust\/crate features, even as a relatively new Rust programmer. <\/li>\n<li>Transparency (like this call for blog posts, RFC process including roadmap)<\/li>\n<li>Focus on good docs &amp; good error reporting is incredibly helpful. Keep iterating on this!<\/li>\n<\/ul>\n<h2>Feature requests<\/h2>\n<ul>\n<li>safety beyond memory safety and concurrency. For example: URL parsing should <strike>be in std<\/strike> have a shared implementation that supports common use cases &#8212; it&#8217;s risky for Internet apps to not have a stable, well vetted URL parser, why are there three? (That&#8217;s a rhetorical question. I know why, but don&#8217;t think there need to be.  See <a href=\"https:\/\/twitter.com\/NikolaiVazquez\/status\/1149063581226295297\">twitter discussion<\/a> [Update 12\/16\/2019: I&#8217;d like to see convergence in URL parsers (or perhaps a shared common library) the way the community seems to be converging around <a href=\"https:\/\/serde.rs\/\">serde<\/a>.]<\/li>\n<li>async all the things! I think this is already the plan. I look forward to async I\/O (network and files) to be supported in the std library. I appreciate the thoughtfulness about safety, factoring out useful core concepts (like Pin\/Task), and ensuring compatibility with Futures and Tokio crates. Consider other async use cases: GPU, OpenGL<\/li>\n<li>lifetimes visualization would accelerate learning curve on resolving compiler errors, good ideas in <a href=\"https:\/\/twitter.com\/ultrasaurus\/status\/1183136267208232961\">this thread<\/a><\/li>\n<\/ul>\n<h2>Slow down to speed up<\/h2>\n<p>In my experience writing documentation often uncovers design issues and bugs. <a href=\"https:\/\/github.com\/rust-lang\/rfcs\/blob\/master\/0000-template.md\">RFC template<\/a> has a <strong>guide-level explanation<\/strong> section, which is great, and taking that one step further to writing baseline docs before declaring a feature &#8220;stable&#8221; would create positive pressure for community focus. Some ideas for process improvements&#8230;<\/p>\n<ul>\n<li>A crisp &#8220;definition of done&#8221; could help focus the community. Consider adding requirements to releasing &#8216;stable&#8217;\n<ul>\n<li>RFC updated to reflect what was completed and is still open<\/li>\n<li>stable reference docs are complete or include link to RFC<\/li>\n<\/ul>\n<\/li>\n<li>Consider WIP limits: <a href=\"https:\/\/leankit.com\/learn\/kanban\/how-to-use-wip-limits-to-increase-speed\/\">how limiting work-in-progress increases speed<\/a><\/li>\n<\/ul>\n<p>It seems in keep with Rust values to create a strong incentive to support contributing writers who are working to take the feature over-the-line and encourage new engineers to contribute. It is easier for new contributors to work with APIs that are documented or clearly dive into a work-in-progress, aware that they are contributing to finishing something.<\/p>\n<h2>Other Improvements<\/h2>\n<ul>\n<li>Documentation shouldn&#8217;t require deep knowledge of Rust (example: https:\/\/stackoverflow.com\/questions\/56402818\/how-do-i-interpret-the-signature-of-read-until-and-what-is-asyncread-bufread-i\/56403568#56403568)<\/li>\n<\/ul>\n<h2>Background<\/h2>\n<p>The reason I&#8217;m learning Rust is that I am experienced engineer with a need to write performant, low-profile client\/server code. I&#8217;m excited about the idea of writing one body of code that can (potentially) work across native desktop, mobile, servers&#8230; and with cross-compilation to WebAssembly (Wasm), also browsers and edge servers.<\/p>\n<p>Arguably, C works for all my needs, it even cross-compiles to Wasm.  I want to like Rust better. I do in theory, but in practice, it&#8217;s got a lot of sharp edges (which is saying a lot when comparing it to C).<\/p>\n<hr \/>\n<p>Updated Dec 2019 to modify the introduction, so excerpt is useful (if <a href=\"https:\/\/readrust.net\/rust-2020\">rust2020 summary post<\/a> is ever updated.  Original text below:<\/p>\n<p>answering the Rust programming language <a href=\"https:\/\/blog.rust-lang.org\/2019\/10\/29\/A-call-for-blogs-2020.html\">call for blog posts<\/a> as input to the 2020 roadmap<\/p>\n<p><em>Caveat: I am new to Rust. There&#8217;s probably stuff I don&#8217;t even know about that is more important than anything here. This is just me doing my part to give back to the awesome Rust community.<\/em><\/p>\n","protected":false},"excerpt":{"rendered":"<p>As a newcomer to Rust, my suggestion for 2020 theme is to fulfill the promise of &#8220;empowering everyone to build reliable and efficient software&#8221; by finishing what&#8217;s started (rather than adding new features), continuing the focus on good docs and good tools, and expanding to develop a coherent ecosystem. Rust empowers you to reach farther,&hellip; <a href=\"https:\/\/www.ultrasaurus.com\/2019\/12\/rust-2020\/\">Continue reading <span class=\"meta-nav\">&rarr;<\/span><\/a><\/p>\n","protected":false},"author":84,"featured_media":0,"comment_status":"open","ping_status":"open","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.ultrasaurus.com\/wp-json\/wp\/v2\/posts\/6885"}],"collection":[{"href":"https:\/\/www.ultrasaurus.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.ultrasaurus.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.ultrasaurus.com\/wp-json\/wp\/v2\/users\/84"}],"replies":[{"embeddable":true,"href":"https:\/\/www.ultrasaurus.com\/wp-json\/wp\/v2\/comments?post=6885"}],"version-history":[{"count":22,"href":"https:\/\/www.ultrasaurus.com\/wp-json\/wp\/v2\/posts\/6885\/revisions"}],"predecessor-version":[{"id":6960,"href":"https:\/\/www.ultrasaurus.com\/wp-json\/wp\/v2\/posts\/6885\/revisions\/6960"}],"wp:attachment":[{"href":"https:\/\/www.ultrasaurus.com\/wp-json\/wp\/v2\/media?parent=6885"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.ultrasaurus.com\/wp-json\/wp\/v2\/categories?post=6885"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.ultrasaurus.com\/wp-json\/wp\/v2\/tags?post=6885"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}